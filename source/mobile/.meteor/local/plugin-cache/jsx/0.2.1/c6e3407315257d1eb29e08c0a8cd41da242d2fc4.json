{"metadata":{"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}},"usedHelpers":[]},"ignored":false,"code":"\nvar _defaultMessagesLimit = 30;\nvar _incrementalMessageLimit = 20;\nvar _initLoading = true;\nvar _currentScrollPosition = 0;\n\nvar incrementalScroll = function (e) {\n\n  var scrollY = (this.y || window.pageYOffset) - window.pageYOffset;\n  this.y = window.pageYOffset;\n  _triggerLoadMore(scrollY, window.pageYOffset);\n};\n\nvar _triggerLoadMore = function (scrollY, offsetY) {\n  var directionY = !scrollY ? \"NONE\" : scrollY > 0 ? \"UP\" : \"DOWN\";\n  if (directionY === \"UP\" && offsetY === 0) {\n    console.log(\"window.scroll passed this line\", offsetY);\n    _resetMessageSubLimit();\n  }\n};\n\nvar _resetMessageSubLimit = function () {\n\n  var before = Session.get(\"Message_Sub_Limit\");\n  var after = before + _incrementalMessageLimit;\n  Session.set(\"Message_Sub_Limit\", after);\n};\n\nIH.RC.ChatView = React.createClass({\n  displayName: \"ChatView\",\n\n  mixins: [ReactMeteorData],\n\n  getInitialState: function () {\n    return { messageSubLimit: _defaultMessagesLimit };\n  },\n  getMeteorData: function () {\n    var channelId = this.props.channelID || FlowRouter.getParam(\"slug\");\n    var messageLimit = Session.get(\"Message_Sub_Limit\") || _defaultMessagesLimit;\n\n    this.handle1 = Meteor.subscribe(\"ChatMessageList\", channelId, messageLimit);\n    this.handle2 = Meteor.subscribe(\"ChatMessageUser\", channelId);\n\n    this.subscriptionsReady = this.handle1.ready() && this.handle2.ready();\n\n    var query = {\n      CHID: channelId\n    };\n    var options = {\n      sort: { createdAt: 1 }\n    };\n\n    var channel, messages;\n\n    if (this.subscriptionsReady) {\n\n      if (this.initialLoading) {\n        IH.Action.ChatStatus.activateChannel(this.props.channelID);\n        this.initialLoading = false;\n      }\n\n      channel = IH.Coll.ChatChannels.findOne(channelId);\n      messages = IH.Coll.ChatMessages.find(query, options).map(function (m) {\n        user = Meteor.users.findOne(m.SID).profile;\n\n        return {\n          from: m.SID,\n          msg: m.content,\n          date: m.createdAt,\n          type: m.type,\n          avatar: user.avatar,\n          name: user.name,\n          gender: user.gender\n        };\n      });\n    }\n\n    return {\n      channel: channel,\n      messages: messages\n    };\n  },\n  componentWillMount: function () {\n    Session.set(\"Message_Sub_Limit\", _defaultMessagesLimit);\n    this.props.channelID = this.props.channelID || FlowRouter.getParam(\"slug\");\n    this.initialLoading = true;\n  },\n  componentDidMount: function () {\n    window.addEventListener(\"scroll\", incrementalScroll);\n  },\n  componentWillUpdate: function () {\n    var node = this.refs.messageContainer.getDOMNode();\n    this.shouldScrollBottom = node.scrollTop + node.offsetHeight === node.scrollHeight;\n    //_currentScrollPosition = node.scrollHeight;\n  },\n  componentDidUpdate: function () {\n    var node = this.refs.messageContainer.getDOMNode();\n\n    if (this.handle1.ready() && this.handle2.ready()) {\n      if (this.shouldScrollBottom) {\n        console.log(\"node.scrollHeight in update \", node.scrollHeight);\n        if (_initLoading && this.data.messages) {\n          window.scrollTo(0, 10000);\n          _initLoading = false;\n        } else {\n          node.scrollTop = node.scrollHeight;\n        }\n      } else {\n        //console.log(\"_currentScrollPosition\", _currentScrollPosition, node.scrollHeight)\n\n        node.scrollTop = _currentScrollPosition; // why this doesn't work??\n      }\n      _currentScrollPosition = node.scrollHeight;\n    }\n  },\n  componentWillUnmount: function () {\n\n    // web should use a different approach,\n    // e.g. remove from active channel list\n\n    this.handle1.stop();\n    this.handle2.stop();\n    window.removeEventListener(\"scroll\");\n\n    IH.Action.ChatStatus.deActivateChannel(this.props.channelID);\n    Session.set(\"ACTIVE_CHAT_CHANNEL\", null);\n  },\n  sendNewMessage: function (msg) {\n    var message = {\n      type: \"txt\",\n      content: msg,\n      SID: Meteor.userId(),\n      CHID: this.props.channelID\n    };\n    IH.Action.ChatMessages.createMessage(message, this.props.channelID);\n  },\n  takeNSendPhoto: function () {\n\n    // TODO: added \"camera\" button\n\n    if (Meteor.isCordova) {\n      var msg;\n      Camera.getPicture({}, function (e, pic) {\n        if (e) {\n          Meteor.setTimeout(function () {\n            alert(\"e.message)\");\n          }, 0);\n        } else {\n          msg = pic;\n        }\n      });\n\n      var message = {\n        type: \"img\",\n        content: msg,\n        SID: Meteor.userId(),\n        CHID: this.props.channelID\n      };\n      IH.Action.ChatMessages.createMessage(message, this.props.channelID);\n    } else {\n      alert(\"Web camera is not supported yet.\");\n    }\n  },\n  getDataContent: function () {\n    //return <IH.RC.ChatMessageList messages={this.data.messages} {...this.props}/>; // user props...\n\n    var lastMsg = {};\n    var userId = Meteor.userId();\n\n    return React.createElement(\n      \"div\",\n      null,\n      _.map(this.data.messages, function (m, n) {\n        var first = n === 0 ? true : !(h.nk(lastMsg, \"m.name\") == h.nk(m, \"m.name\"));\n        var dateBreak = moment(m.date).format(\"MM/DD/YY\");\n        var lastBreak = n === 0 || !lastMsg.date ? null : moment(lastMsg.date).format(\"MM/DD/YY\");\n        lastMsg = m;\n\n        // TODO: use <img> for type==\"img\"\n\n        return React.createElement(RC.ChatBubble, {\n          key: n,\n          isUser: userId == m.from,\n          showDateBreak: dateBreak != lastBreak,\n          firstOfGroup: first,\n          message: m.msg,\n          date: m.date,\n          avatar: m.avatar,\n          name: m.name,\n          gender: m.gender\n        });\n      }),\n      React.createElement(RC.ChatTextArea, { name: \"message\", onSubmit: this.sendNewMessage })\n    );\n  },\n\n  render: function () {\n    var subscriptionsReady = this.subscriptionsReady;\n\n    return React.createElement(\n      \"div\",\n      { ref: \"messageContainer\" },\n      subscriptionsReady ? this.getDataContent() : React.createElement(\n        \"p\",\n        null,\n        \"Loading...\"\n      )\n    );\n  }\n});","ast":null,"map":{"version":3,"sources":["/components/ChatView.jsx"],"names":[],"mappings":"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","file":"/components/ChatView.jsx.map","sourcesContent":["\nvar _defaultMessagesLimit = 30;\nvar _incrementalMessageLimit = 20;\nvar _initLoading = true;\nvar _currentScrollPosition = 0;\n\nvar incrementalScroll = function (e) {\n\n  var scrollY = (this.y || window.pageYOffset) - window.pageYOffset;\n  this.y = window.pageYOffset;\n  _triggerLoadMore(scrollY, window.pageYOffset);\n};\n\nvar _triggerLoadMore = function(scrollY, offsetY) {\n  var directionY = !scrollY ? \"NONE\" : scrollY > 0 ? \"UP\" : \"DOWN\"\n  if (directionY === \"UP\" && offsetY === 0 ) {\n    console.log(\"window.scroll passed this line\", offsetY)\n    _resetMessageSubLimit()\n  }\n};\n\nvar _resetMessageSubLimit = function (){\n\n  var before = Session.get(\"Message_Sub_Limit\");\n  var after = before + _incrementalMessageLimit;\n  Session.set(\"Message_Sub_Limit\", after)\n};\n\nIH.RC.ChatView = React.createClass({\n  mixins: [ReactMeteorData],\n\n  getInitialState(){\n    return {messageSubLimit: _defaultMessagesLimit}\n  },\n  getMeteorData() {\n    var channelId = this.props.channelID || FlowRouter.getParam(\"slug\");\n    var messageLimit = Session.get(\"Message_Sub_Limit\") || _defaultMessagesLimit;\n\n    this.handle1 = Meteor.subscribe(\"ChatMessageList\", channelId, messageLimit);\n    this.handle2 =  Meteor.subscribe(\"ChatMessageUser\", channelId)\n\n    this.subscriptionsReady = this.handle1.ready() && this.handle2.ready();\n\n    var query = {\n      CHID: channelId\n    };\n    var options = {\n      sort: {createdAt: 1}\n    };\n\n    var channel, messages;\n\n    if (this.subscriptionsReady) {\n\n      if (this.initialLoading) {\n        IH.Action.ChatStatus.activateChannel(this.props.channelID);\n        this.initialLoading = false;\n      }\n\n      channel = IH.Coll.ChatChannels.findOne(channelId);\n      messages = IH.Coll.ChatMessages.find(query, options).map(function(m){\n        user = Meteor.users.findOne(m.SID).profile;\n\n        return {\n          from: m.SID,\n          msg: m.content,\n          date: m.createdAt,\n          type: m.type,\n          avatar: user.avatar,\n          name: user.name,\n          gender: user.gender\n        }\n      });\n    }\n\n    return {\n      channel: channel,\n      messages: messages\n    }\n  },\n  componentWillMount() {\n    Session.set(\"Message_Sub_Limit\", _defaultMessagesLimit);\n    this.props.channelID = this.props.channelID || FlowRouter.getParam(\"slug\");\n    this.initialLoading = true;\n  },\n  componentDidMount() {\n    window.addEventListener(\"scroll\", incrementalScroll);\n  },\n  componentWillUpdate() {\n    var node = this.refs.messageContainer.getDOMNode();\n    this.shouldScrollBottom = node.scrollTop + node.offsetHeight === node.scrollHeight;\n    //_currentScrollPosition = node.scrollHeight;\n  },\n  componentDidUpdate() {\n    var node = this.refs.messageContainer.getDOMNode();\n\n    if (this.handle1.ready() && this.handle2.ready() ) {\n      if (this.shouldScrollBottom) {\n        console.log(\"node.scrollHeight in update \", node.scrollHeight);\n        if (_initLoading && this.data.messages) {\n          window.scrollTo(0, 10000);\n          _initLoading = false;\n        } else {\n          node.scrollTop = node.scrollHeight;\n        }\n      } else {\n        //console.log(\"_currentScrollPosition\", _currentScrollPosition, node.scrollHeight)\n\n        node.scrollTop = _currentScrollPosition;   // why this doesn't work??\n      }\n      _currentScrollPosition = node.scrollHeight;\n    }\n  },\n  componentWillUnmount() {\n\n    // web should use a different approach,\n    // e.g. remove from active channel list\n\n    this.handle1.stop();\n    this.handle2.stop();\n    window.removeEventListener(\"scroll\");\n\n    IH.Action.ChatStatus.deActivateChannel(this.props.channelID);\n    Session.set(\"ACTIVE_CHAT_CHANNEL\", null);\n  },\n  sendNewMessage(msg) {\n    let message = {\n      type: \"txt\",\n      content: msg,\n      SID: Meteor.userId(),\n      CHID: this.props.channelID\n    };\n    IH.Action.ChatMessages.createMessage(message, this.props.channelID)\n  },\n  takeNSendPhoto() {\n\n    // TODO: added \"camera\" button\n\n    if (Meteor.isCordova) {\n      var msg;\n      Camera.getPicture({}, function(e, pic){\n        if (e) {\n          Meteor.setTimeout(function() {\n            alert(\"e.message)\")\n          }, 0);\n        } else {\n          msg = pic;\n        }\n      })\n\n      let message = {\n        type: \"img\",\n        content: msg,\n        SID: Meteor.userId(),\n        CHID: this.props.channelID\n      };\n      IH.Action.ChatMessages.createMessage(message, this.props.channelID)\n\n    } else {\n      alert(\"Web camera is not supported yet.\")\n    }\n  },\n  getDataContent(){\n    //return <IH.RC.ChatMessageList messages={this.data.messages} {...this.props}/>; // user props...\n\n    var lastMsg = {}\n    let userId = Meteor.userId();\n\n    return <div>\n      {\n        _.map(this.data.messages, function(m, n){\n          let first = n===0 ? true : !(h.nk(lastMsg, \"m.name\")==h.nk(m, \"m.name\"));\n          let dateBreak = moment(m.date).format(\"MM/DD/YY\");\n          let lastBreak = n===0 || !lastMsg.date ? null : moment(lastMsg.date).format(\"MM/DD/YY\");\n          lastMsg = m;\n\n          // TODO: use <img> for type==\"img\"\n\n          return <RC.ChatBubble\n            key={n}\n            isUser={userId==m.from}\n            showDateBreak={dateBreak!=lastBreak}\n            firstOfGroup={first}\n            message={m.msg}\n            date={m.date}\n            avatar={m.avatar}\n            name={m.name}\n            gender={m.gender}\n            />\n        })\n      }\n      <RC.ChatTextArea name=\"message\" onSubmit={this.sendNewMessage} />\n    </div>\n  },\n\n\n  render() {\n    var subscriptionsReady = this.subscriptionsReady;\n\n    return <div ref=\"messageContainer\">\n      { subscriptionsReady? this.getDataContent() : <p>Loading...</p> }\n    </div>\n  }\n})"]},"hash":"c6e3407315257d1eb29e08c0a8cd41da242d2fc4"}
