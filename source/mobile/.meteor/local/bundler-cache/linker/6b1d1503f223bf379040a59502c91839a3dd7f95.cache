[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar MeteorFlux = Package['meteorflux:namespace'].MeteorFlux;\n\n/* Package-scope variables */\nvar Dispatcher;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////\n//                                                                             //\n// packages/meteorflux_dispatcher/lib/dispatcher.js                            //\n//                                                                             //\n/////////////////////////////////////////////////////////////////////////////////\n                                                                               //\n                                                                               // 1\nvar _lastID = 1;                                                               // 2\nvar _prefix = 'ID_';                                                           // 3\n                                                                               // 4\nvar invariant = function(condition, errorMessage, format, a, b, c, d, e, f) {  // 5\n  if (!condition) {                                                            // 6\n    var error;                                                                 // 7\n    if ((format === undefined)||(errorMessage === undefined)) {                // 8\n      error = new Meteor.Error(                                                // 9\n        'minified-exception',                                                  // 10\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'          // 12\n      );                                                                       // 13\n    } else {                                                                   // 14\n      var args = [a, b, c, d, e, f];                                           // 15\n      var argIndex = 0;                                                        // 16\n      error = new Meteor.Error(                                                // 17\n        errorMessage,                                                          // 18\n        'Invariant Violation: ' +                                              // 19\n        format.replace(/%s/g, function() { return args[argIndex++]; })         // 20\n      );                                                                       // 21\n    }                                                                          // 22\n    error.framesToPop = 1; // we don't care about invariant's own frame        // 23\n    throw error;                                                               // 24\n  }                                                                            // 25\n};                                                                             // 26\n                                                                               // 27\n/**                                                                            // 28\n* MeteorFlux.Dispatcher is used to broadcast payloads to registered callbacks.\n*/                                                                             // 30\n                                                                               // 31\nMeteorFlux.Dispatcher = function(){                                            // 32\n  this._callbacks = {};                                                        // 33\n  this._isPending = {};                                                        // 34\n  this._isHandled = {};                                                        // 35\n  this._isDispatching = false;                                                 // 36\n  this._pendingPayload = null;                                                 // 37\n};                                                                             // 38\n                                                                               // 39\n                                                                               // 40\n/**                                                                            // 41\n* Registers a callback to be invoked with every dispatched payload. Returns    // 42\n* a token that can be used with `waitFor()`.                                   // 43\n*                                                                              // 44\n* @param {function} callback                                                   // 45\n* @return {string}                                                             // 46\n*/                                                                             // 47\nMeteorFlux.Dispatcher.prototype.register = function(/* arguments */) {         // 48\n  var callback = this._curateCallback.apply(this, arguments);                  // 49\n  var id = _prefix + _lastID++;                                                // 50\n  this._callbacks[id] = callback;                                              // 51\n  return id;                                                                   // 52\n};                                                                             // 53\n                                                                               // 54\n/**                                                                            // 55\n* Removes a callback based on its token.                                       // 56\n*                                                                              // 57\n* @param {string} id                                                           // 58\n*/                                                                             // 59\nMeteorFlux.Dispatcher.prototype.unregister = function(id) {                    // 60\n  invariant(                                                                   // 61\n    this._callbacks[id],                                                       // 62\n    'dispatcher-unregister-not-map',                                           // 63\n    'Dispatcher.unregister(...): `%s` does not map to a registered callback.',\n    id                                                                         // 65\n  );                                                                           // 66\n  delete this._callbacks[id];                                                  // 67\n};                                                                             // 68\n                                                                               // 69\n/**                                                                            // 70\n* Waits for the callbacks specified to be invoked before continuing execution  // 71\n* of the current callback. This method should only be used by a callback in    // 72\n* response to a dispatched payload.                                            // 73\n*                                                                              // 74\n* @param {array<string>} ids                                                   // 75\n*/                                                                             // 76\nMeteorFlux.Dispatcher.prototype.waitFor = function(ids) {                      // 77\n  invariant(                                                                   // 78\n    this._isDispatching,                                                       // 79\n    'dispatcher-waitfor-invoked-outside-dispatch',                             // 80\n    'Dispatcher.waitFor(...): Must be invoked while dispatching.'              // 81\n  );                                                                           // 82\n  for (var ii = 0; ii < ids.length; ii++) {                                    // 83\n    var id = ids[ii];                                                          // 84\n    if (this._isPending[id]) {                                                 // 85\n      invariant(                                                               // 86\n        this._isHandled[id],                                                   // 87\n        'dispatcher-waitfor-circular-dependency',                              // 88\n        'Dispatcher.waitFor(...): Circular dependency detected while ' +       // 89\n        'waiting for `%s`.',                                                   // 90\n        id                                                                     // 91\n      );                                                                       // 92\n      continue;                                                                // 93\n    }                                                                          // 94\n    invariant(                                                                 // 95\n      this._callbacks[id],                                                     // 96\n      'dispatcher-waitfor-invalid-token',                                      // 97\n      'Dispatcher.waitFor(...): `%s` does not map to a registered callback.',  // 98\n      id                                                                       // 99\n    );                                                                         // 100\n    this._invokeCallback(id);                                                  // 101\n  }                                                                            // 102\n};                                                                             // 103\n                                                                               // 104\n/**                                                                            // 105\n* Dispatches a payload to all registered callbacks.                            // 106\n*                                                                              // 107\n* @param {object} payload                                                      // 108\n*/                                                                             // 109\nMeteorFlux.Dispatcher.prototype.dispatch = function(/* arguments */) {         // 110\n  invariant(                                                                   // 111\n    !this._isDispatching,                                                      // 112\n    'dispatcher-cant-dispatch-while-dispatching',                              // 113\n    'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.'     // 114\n  );                                                                           // 115\n  var payload = this._curatePayload.apply(this, arguments);                    // 116\n  this._startDispatching(payload);                                             // 117\n  try {                                                                        // 118\n    for (var id in this._callbacks) {                                          // 119\n      if (this._isPending[id]) {                                               // 120\n        continue;                                                              // 121\n      }                                                                        // 122\n      this._invokeCallback(id);                                                // 123\n    }                                                                          // 124\n  } finally {                                                                  // 125\n    this._stopDispatching();                                                   // 126\n  }                                                                            // 127\n};                                                                             // 128\n                                                                               // 129\n/**                                                                            // 130\n* Is this MeteorFlux.Dispatcher currently dispatching.                         // 131\n*                                                                              // 132\n* @return {boolean}                                                            // 133\n*/                                                                             // 134\nMeteorFlux.Dispatcher.prototype.isDispatching = function() {                   // 135\n  return this._isDispatching;                                                  // 136\n};                                                                             // 137\n                                                                               // 138\n/**                                                                            // 139\n* Call the callback stored with the given id. Also do some internal            // 140\n* bookkeeping.                                                                 // 141\n*                                                                              // 142\n* @param {string} id                                                           // 143\n* @internal                                                                    // 144\n*/                                                                             // 145\nMeteorFlux.Dispatcher.prototype._invokeCallback = function(id) {               // 146\n  this._isPending[id] = true;                                                  // 147\n  this._callbacks[id](this._pendingPayload);                                   // 148\n  this._isHandled[id] = true;                                                  // 149\n};                                                                             // 150\n                                                                               // 151\n/**                                                                            // 152\n* Set up bookkeeping needed when dispatching.                                  // 153\n*                                                                              // 154\n* @param {object} payload                                                      // 155\n* @internal                                                                    // 156\n*/                                                                             // 157\nMeteorFlux.Dispatcher.prototype._startDispatching = function(payload) {        // 158\n  for (var id in this._callbacks) {                                            // 159\n    this._isPending[id] = false;                                               // 160\n    this._isHandled[id] = false;                                               // 161\n  }                                                                            // 162\n  this._pendingPayload = payload;                                              // 163\n  this._isDispatching = true;                                                  // 164\n};                                                                             // 165\n                                                                               // 166\n/**                                                                            // 167\n* Clear bookkeeping used for dispatching.                                      // 168\n*                                                                              // 169\n* @internal                                                                    // 170\n*/                                                                             // 171\nMeteorFlux.Dispatcher.prototype._stopDispatching = function() {                // 172\n  this._pendingPayload = null;                                                 // 173\n  this._isDispatching = false;                                                 // 174\n};                                                                             // 175\n                                                                               // 176\n                                                                               // 177\n/**                                                                            // 178\n* Curate the payload. If the user uses the first argument as string, use it    // 179\n* as action type and include it in the payload.                                // 180\n*                                                                              // 181\n* @internal                                                                    // 182\n*/                                                                             // 183\nMeteorFlux.Dispatcher.prototype._curatePayload = function(/* arguments */) {   // 184\n  if (typeof arguments[0] === 'string') {                                      // 185\n    var action = arguments[1] || {};                                           // 186\n    action.type = arguments[0];                                                // 187\n    return action;                                                             // 188\n  } else {                                                                     // 189\n    return arguments[0];                                                       // 190\n  }                                                                            // 191\n};                                                                             // 192\n                                                                               // 193\n/**                                                                            // 194\n* Curate the payload. If the user uses the first argument as string, use it    // 195\n* as action type and include it in the payload.                                // 196\n*                                                                              // 197\n* @internal                                                                    // 198\n*/                                                                             // 199\nMeteorFlux.Dispatcher.prototype._curateCallback = function(/* arguments */) {  // 200\n  if (typeof arguments[0] === 'string') {                                      // 201\n    var type = arguments[0];                                                   // 202\n    var func = arguments[1];                                                   // 203\n    return function(action) {                                                  // 204\n      if (action.type === type)                                                // 205\n        func(action);                                                          // 206\n    };                                                                         // 207\n  } else {                                                                     // 208\n    return arguments[0];                                                       // 209\n  }                                                                            // 210\n};                                                                             // 211\n                                                                               // 212\n/**                                                                            // 213\n* Reset everything. Created for testing purposes                               // 214\n*                                                                              // 215\n*/                                                                             // 216\nMeteorFlux.Dispatcher.prototype.reset = function() {                           // 217\n  this._callbacks = {};                                                        // 218\n  this._isPending = {};                                                        // 219\n  this._isHandled = {};                                                        // 220\n  this._isDispatching = false;                                                 // 221\n  this._pendingPayload = null;                                                 // 222\n};                                                                             // 223\n                                                                               // 224\n/**                                                                            // 225\n* The main Dispatcher instance that clients will deal with                     // 226\n*                                                                              // 227\n* @exports Dispatcher                                                          // 228\n*/                                                                             // 229\n                                                                               // 230\nDispatcher = new MeteorFlux.Dispatcher();                                      // 231\n                                                                               // 232\n/////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['meteorflux:dispatcher'] = {\n  Dispatcher: Dispatcher\n};\n\n})();\n","servePath":"/packages/meteorflux_dispatcher.js","sourceMap":{"version":3,"sources":["/packages/meteorflux_dispatcher/lib/dispatcher.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qF","file":"/packages/meteorflux_dispatcher.js","sourcesContent":["\nvar _lastID = 1;\nvar _prefix = 'ID_';\n\nvar invariant = function(condition, errorMessage, format, a, b, c, d, e, f) {\n  if (!condition) {\n    var error;\n    if ((format === undefined)||(errorMessage === undefined)) {\n      error = new Meteor.Error(\n        'minified-exception',\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Meteor.Error(\n        errorMessage,\n        'Invariant Violation: ' +\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n    }\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\n/**\n* MeteorFlux.Dispatcher is used to broadcast payloads to registered callbacks.\n*/\n\nMeteorFlux.Dispatcher = function(){\n  this._callbacks = {};\n  this._isPending = {};\n  this._isHandled = {};\n  this._isDispatching = false;\n  this._pendingPayload = null;\n};\n\n\n/**\n* Registers a callback to be invoked with every dispatched payload. Returns\n* a token that can be used with `waitFor()`.\n*\n* @param {function} callback\n* @return {string}\n*/\nMeteorFlux.Dispatcher.prototype.register = function(/* arguments */) {\n  var callback = this._curateCallback.apply(this, arguments);\n  var id = _prefix + _lastID++;\n  this._callbacks[id] = callback;\n  return id;\n};\n\n/**\n* Removes a callback based on its token.\n*\n* @param {string} id\n*/\nMeteorFlux.Dispatcher.prototype.unregister = function(id) {\n  invariant(\n    this._callbacks[id],\n    'dispatcher-unregister-not-map',\n    'Dispatcher.unregister(...): `%s` does not map to a registered callback.',\n    id\n  );\n  delete this._callbacks[id];\n};\n\n/**\n* Waits for the callbacks specified to be invoked before continuing execution\n* of the current callback. This method should only be used by a callback in\n* response to a dispatched payload.\n*\n* @param {array<string>} ids\n*/\nMeteorFlux.Dispatcher.prototype.waitFor = function(ids) {\n  invariant(\n    this._isDispatching,\n    'dispatcher-waitfor-invoked-outside-dispatch',\n    'Dispatcher.waitFor(...): Must be invoked while dispatching.'\n  );\n  for (var ii = 0; ii < ids.length; ii++) {\n    var id = ids[ii];\n    if (this._isPending[id]) {\n      invariant(\n        this._isHandled[id],\n        'dispatcher-waitfor-circular-dependency',\n        'Dispatcher.waitFor(...): Circular dependency detected while ' +\n        'waiting for `%s`.',\n        id\n      );\n      continue;\n    }\n    invariant(\n      this._callbacks[id],\n      'dispatcher-waitfor-invalid-token',\n      'Dispatcher.waitFor(...): `%s` does not map to a registered callback.',\n      id\n    );\n    this._invokeCallback(id);\n  }\n};\n\n/**\n* Dispatches a payload to all registered callbacks.\n*\n* @param {object} payload\n*/\nMeteorFlux.Dispatcher.prototype.dispatch = function(/* arguments */) {\n  invariant(\n    !this._isDispatching,\n    'dispatcher-cant-dispatch-while-dispatching',\n    'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.'\n  );\n  var payload = this._curatePayload.apply(this, arguments);\n  this._startDispatching(payload);\n  try {\n    for (var id in this._callbacks) {\n      if (this._isPending[id]) {\n        continue;\n      }\n      this._invokeCallback(id);\n    }\n  } finally {\n    this._stopDispatching();\n  }\n};\n\n/**\n* Is this MeteorFlux.Dispatcher currently dispatching.\n*\n* @return {boolean}\n*/\nMeteorFlux.Dispatcher.prototype.isDispatching = function() {\n  return this._isDispatching;\n};\n\n/**\n* Call the callback stored with the given id. Also do some internal\n* bookkeeping.\n*\n* @param {string} id\n* @internal\n*/\nMeteorFlux.Dispatcher.prototype._invokeCallback = function(id) {\n  this._isPending[id] = true;\n  this._callbacks[id](this._pendingPayload);\n  this._isHandled[id] = true;\n};\n\n/**\n* Set up bookkeeping needed when dispatching.\n*\n* @param {object} payload\n* @internal\n*/\nMeteorFlux.Dispatcher.prototype._startDispatching = function(payload) {\n  for (var id in this._callbacks) {\n    this._isPending[id] = false;\n    this._isHandled[id] = false;\n  }\n  this._pendingPayload = payload;\n  this._isDispatching = true;\n};\n\n/**\n* Clear bookkeeping used for dispatching.\n*\n* @internal\n*/\nMeteorFlux.Dispatcher.prototype._stopDispatching = function() {\n  this._pendingPayload = null;\n  this._isDispatching = false;\n};\n\n\n/**\n* Curate the payload. If the user uses the first argument as string, use it\n* as action type and include it in the payload.\n*\n* @internal\n*/\nMeteorFlux.Dispatcher.prototype._curatePayload = function(/* arguments */) {\n  if (typeof arguments[0] === 'string') {\n    var action = arguments[1] || {};\n    action.type = arguments[0];\n    return action;\n  } else {\n    return arguments[0];\n  }\n};\n\n/**\n* Curate the payload. If the user uses the first argument as string, use it\n* as action type and include it in the payload.\n*\n* @internal\n*/\nMeteorFlux.Dispatcher.prototype._curateCallback = function(/* arguments */) {\n  if (typeof arguments[0] === 'string') {\n    var type = arguments[0];\n    var func = arguments[1];\n    return function(action) {\n      if (action.type === type)\n        func(action);\n    };\n  } else {\n    return arguments[0];\n  }\n};\n\n/**\n* Reset everything. Created for testing purposes\n*\n*/\nMeteorFlux.Dispatcher.prototype.reset = function() {\n  this._callbacks = {};\n  this._isPending = {};\n  this._isHandled = {};\n  this._isDispatching = false;\n  this._pendingPayload = null;\n};\n\n/**\n* The main Dispatcher instance that clients will deal with\n*\n* @exports Dispatcher\n*/\n\nDispatcher = new MeteorFlux.Dispatcher();\n"]}}]