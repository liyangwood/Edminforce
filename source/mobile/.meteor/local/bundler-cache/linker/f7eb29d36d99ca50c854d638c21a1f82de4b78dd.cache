[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar _ = Package.underscore._;\nvar Random = Package.random.Random;\n\n/* Package-scope variables */\nvar RateLimiter;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                     //\n// packages/rate-limit/packages/rate-limit.js                                          //\n//                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////\n                                                                                       //\n(function(){                                                                           // 1\n                                                                                       // 2\n//////////////////////////////////////////////////////////////////////////////////     // 3\n//                                                                              //     // 4\n// packages/rate-limit/rate-limit.js                                            //     // 5\n//                                                                              //     // 6\n//////////////////////////////////////////////////////////////////////////////////     // 7\n                                                                                //     // 8\n// Default time interval (in milliseconds) to reset rate limit counters         // 1   // 9\nvar DEFAULT_INTERVAL_TIME_IN_MILLISECONDS = 1000;                               // 2   // 10\n// Default number of events allowed per time interval                           // 3   // 11\nvar DEFAULT_REQUESTS_PER_INTERVAL = 10;                                         // 4   // 12\n                                                                                // 5   // 13\n// A rule is defined by an options object that contains two fields,             // 6   // 14\n// `numRequestsAllowed` which is the number of events allowed per interval, and        // 15\n// an `intervalTime` which is the amount of time in milliseconds before the     // 8   // 16\n// rate limit restarts its internal counters, and by a matchers object. A       // 9   // 17\n// matchers object is a POJO that contains a set of keys with values that       // 10  // 18\n// define the entire set of inputs that match for each key. The values can      // 11  // 19\n// either be null (optional), a primitive or a function that returns a boolean  // 12  // 20\n// of whether the provided input's value matches for this key.                  // 13  // 21\n//                                                                              // 14  // 22\n// Rules are uniquely assigned an `id` and they store a dictionary of counters,        // 23\n// which are records used to keep track of inputs that match the rule. If a     // 16  // 24\n// counter reaches the `numRequestsAllowed` within a given `intervalTime`, a    // 17  // 25\n// rate limit is reached and future inputs that map to that counter will        // 18  // 26\n// result in errors being returned to the client.                               // 19  // 27\nvar Rule = function (options, matchers) {                                       // 20  // 28\n  var self = this;                                                              // 21  // 29\n                                                                                // 22  // 30\n  self.id = Random.id();                                                        // 23  // 31\n                                                                                // 24  // 32\n  self.options = options;                                                       // 25  // 33\n                                                                                // 26  // 34\n  self._matchers = matchers;                                                    // 27  // 35\n                                                                                // 28  // 36\n  self._lastResetTime = new Date().getTime();                                   // 29  // 37\n                                                                                // 30  // 38\n  // Dictionary of input keys to counters                                       // 31  // 39\n  self.counters = {};                                                           // 32  // 40\n};                                                                              // 33  // 41\n                                                                                // 34  // 42\n_.extend(Rule.prototype, {                                                      // 35  // 43\n  // Determine if this rule applies to the given input by comparing all         // 36  // 44\n  // rule.matchers. If the match fails, search short circuits instead of        // 37  // 45\n  // iterating through all matchers.                                            // 38  // 46\n  match: function (input) {                                                     // 39  // 47\n    var self = this;                                                            // 40  // 48\n    var ruleMatches = true;                                                     // 41  // 49\n    return _.every(self._matchers, function (matcher, key) {                    // 42  // 50\n      if (matcher !== null) {                                                   // 43  // 51\n        if (!(_.has(input,key))) {                                              // 44  // 52\n          return false;                                                         // 45  // 53\n        } else {                                                                // 46  // 54\n          if (typeof matcher === 'function') {                                  // 47  // 55\n            if (!(matcher(input[key]))) {                                       // 48  // 56\n              return false;                                                     // 49  // 57\n            }                                                                   // 50  // 58\n          } else {                                                              // 51  // 59\n            if (matcher !== input[key]) {                                       // 52  // 60\n              return false;                                                     // 53  // 61\n            }                                                                   // 54  // 62\n          }                                                                     // 55  // 63\n        }                                                                       // 56  // 64\n      }                                                                         // 57  // 65\n      return true;                                                              // 58  // 66\n    });                                                                         // 59  // 67\n  },                                                                            // 60  // 68\n                                                                                // 61  // 69\n  // Generates unique key string for provided input by concatenating all the    // 62  // 70\n  // keys in the matcher with the corresponding values in the input.            // 63  // 71\n  // Only called if rule matches input.                                         // 64  // 72\n  _generateKeyString: function (input) {                                        // 65  // 73\n    var self = this;                                                            // 66  // 74\n    var returnString = \"\";                                                      // 67  // 75\n    _.each(self._matchers, function (matcher, key) {                            // 68  // 76\n      if (matcher !== null) {                                                   // 69  // 77\n        if (typeof matcher === 'function') {                                    // 70  // 78\n          if (matcher(input[key])) {                                            // 71  // 79\n            returnString += key + input[key];                                   // 72  // 80\n          }                                                                     // 73  // 81\n        } else {                                                                // 74  // 82\n          returnString += key + input[key];                                     // 75  // 83\n        }                                                                       // 76  // 84\n      }                                                                         // 77  // 85\n    });                                                                         // 78  // 86\n    return returnString;                                                        // 79  // 87\n  },                                                                            // 80  // 88\n                                                                                // 81  // 89\n  // Applies the provided input and returns the key string, time since counters        // 90\n  // were last reset and time to next reset.                                    // 83  // 91\n  apply: function (input) {                                                     // 84  // 92\n    var self = this;                                                            // 85  // 93\n    var keyString = self._generateKeyString(input);                             // 86  // 94\n    var timeSinceLastReset = new Date().getTime() - self._lastResetTime;        // 87  // 95\n    var timeToNextReset = self.options.intervalTime - timeSinceLastReset;       // 88  // 96\n    return {                                                                    // 89  // 97\n      key: keyString,                                                           // 90  // 98\n      timeSinceLastReset: timeSinceLastReset,                                   // 91  // 99\n      timeToNextReset: timeToNextReset                                          // 92  // 100\n    };                                                                          // 93  // 101\n  },                                                                            // 94  // 102\n  // Reset counter dictionary for this specific rule. Called once the           // 95  // 103\n  // timeSinceLastReset has exceeded the intervalTime. _lastResetTime is        // 96  // 104\n  // set to be the current time in milliseconds.                                // 97  // 105\n  resetCounter: function () {                                                   // 98  // 106\n    var self = this;                                                            // 99  // 107\n                                                                                // 100\n    // Delete the old counters dictionary to allow for garbage collection       // 101\n    self.counters = {};                                                         // 102\n    self._lastResetTime = new Date().getTime();                                 // 103\n  }                                                                             // 104\n});                                                                             // 105\n                                                                                // 106\n// Initialize rules to be an empty dictionary.                                  // 107\nRateLimiter = function () {                                                     // 108\n  var self = this;                                                              // 109\n                                                                                // 110\n  // Dictionary of all rules associated with this RateLimiter, keyed by their   // 111\n  // id. Each rule object stores the rule pattern, number of events allowed,    // 112\n  // last reset time and the rule reset interval in milliseconds.               // 113\n  self.rules = {};                                                              // 114\n};                                                                              // 115\n                                                                                // 116\n/**                                                                             // 117\n * Checks if this input has exceeded any rate limits.                           // 118\n * @param  {object} input dictionary containing key-value pairs of attributes   // 119\n * that match to rules                                                          // 120\n * @return {object} Returns object of following structure                       // 121\n * { 'allowed': boolean - is this input allowed                                 // 122\n *   'timeToReset': integer | Infinity - returns time until counters are reset  // 123\n *                   in milliseconds                                            // 124\n *   'numInvocationsLeft': integer | Infinity - returns number of calls left    // 125\n *   before limit is reached                                                    // 126\n * }                                                                            // 127\n * If multiple rules match, the least number of invocations left is returned.   // 128\n * If the rate limit has been reached, the longest timeToReset is returned.     // 129\n */                                                                             // 130\nRateLimiter.prototype.check = function (input) {                                // 131\n  var self = this;                                                              // 132\n  var reply = {                                                                 // 133\n    allowed: true,                                                              // 134\n    timeToReset: 0,                                                             // 135\n    numInvocationsLeft: Infinity                                                // 136\n  };                                                                            // 137\n                                                                                // 138\n  var matchedRules = self._findAllMatchingRules(input);                         // 139\n  _.each(matchedRules, function (rule) {                                        // 140\n    var ruleResult = rule.apply(input);                                         // 141\n    var numInvocations = rule.counters[ruleResult.key];                         // 142\n                                                                                // 143\n    if (ruleResult.timeToNextReset < 0) {                                       // 144\n      // Reset all the counters since the rule has reset                        // 145\n      rule.resetCounter();                                                      // 146\n      ruleResult.timeSinceLastReset = new Date().getTime() -                    // 147\n        rule._lastResetTime;                                                    // 148\n      ruleResult.timeToNextReset = rule.options.intervalTime;                   // 149\n      numInvocations = 0;                                                       // 150\n    }                                                                           // 151\n                                                                                // 152\n    if (numInvocations > rule.options.numRequestsAllowed) {                     // 153\n      // Only update timeToReset if the new time would be longer than the       // 154\n      // previously set time. This is to ensure that if this input triggers     // 155\n      // multiple rules, we return the longest period of time until they can    // 156\n      // successfully make another call                                         // 157\n      if (reply.timeToReset < ruleResult.timeToNextReset) {                     // 158\n        reply.timeToReset = ruleResult.timeToNextReset;                         // 159\n      };                                                                        // 160\n      reply.allowed = false;                                                    // 161\n      reply.numInvocationsLeft = 0;                                             // 162\n    } else {                                                                    // 163\n      // If this is an allowed attempt and we haven't failed on any of the      // 164\n      // other rules that match, update the reply field.                        // 165\n      if (rule.options.numRequestsAllowed - numInvocations <                    // 166\n        reply.numInvocationsLeft && reply.allowed) {                            // 167\n        reply.timeToReset = ruleResult.timeToNextReset;                         // 168\n        reply.numInvocationsLeft = rule.options.numRequestsAllowed -            // 169\n          numInvocations;                                                       // 170\n      }                                                                         // 171\n    }                                                                           // 172\n  });                                                                           // 173\n  return reply;                                                                 // 174\n};                                                                              // 175\n                                                                                // 176\n/**                                                                             // 177\n * Adds a rule to dictionary of rules that are checked against on every call.   // 178\n * Only inputs that pass all of the rules will be allowed. Returns unique rule  // 179\n * id that can be passed to `removeRule`.                                       // 180\n * @param {object} rule    Input dictionary defining certain attributes and     // 181\n * rules associated with them.                                                  // 182\n * Each attribute's value can either be a value, a function or null. All        // 183\n * functions must return a boolean of whether the input is matched by that      // 184\n * attribute's rule or not                                                      // 185\n * @param {integer} numRequestsAllowed Optional. Number of events allowed per   // 186\n * interval. Default = 10.                                                      // 187\n * @param {integer} intervalTime Optional. Number of milliseconds before        // 188\n * rule's counters are reset. Default = 1000.                                   // 189\n * @return {string} Returns unique rule id                                      // 190\n */                                                                             // 191\nRateLimiter.prototype.addRule = function (rule, numRequestsAllowed,             // 192\n  intervalTime) {                                                               // 193\n  var self = this;                                                              // 194\n                                                                                // 195\n  var options = {                                                               // 196\n    numRequestsAllowed: numRequestsAllowed || DEFAULT_REQUESTS_PER_INTERVAL,    // 197\n    intervalTime: intervalTime || DEFAULT_INTERVAL_TIME_IN_MILLISECONDS         // 198\n  };                                                                            // 199\n                                                                                // 200\n  var newRule = new Rule(options, rule);                                        // 201\n  this.rules[newRule.id] = newRule;                                             // 202\n  return newRule.id;                                                            // 203\n};                                                                              // 204\n                                                                                // 205\n/**                                                                             // 206\n * Increment counters in every rule that match to this input                    // 207\n * @param  {object} input Dictionary object containing attributes that may      // 208\n * match to rules                                                               // 209\n */                                                                             // 210\nRateLimiter.prototype.increment = function (input) {                            // 211\n  var self = this;                                                              // 212\n                                                                                // 213\n  // Only increment rule counters that match this input                         // 214\n  var matchedRules = self._findAllMatchingRules(input);                         // 215\n  _.each(matchedRules, function (rule) {                                        // 216\n    var ruleResult = rule.apply(input);                                         // 217\n                                                                                // 218\n    if (ruleResult.timeSinceLastReset > rule.options.intervalTime) {            // 219\n      // Reset all the counters since the rule has reset                        // 220\n      rule.resetCounter();                                                      // 221\n    }                                                                           // 222\n                                                                                // 223\n    // Check whether the key exists, incrementing it if so or otherwise         // 224\n    // adding the key and setting its value to 1                                // 225\n    if (_.has(rule.counters, ruleResult.key))                                   // 226\n      rule.counters[ruleResult.key]++;                                          // 227\n    else                                                                        // 228\n      rule.counters[ruleResult.key] = 1;                                        // 229\n  });                                                                           // 230\n};                                                                              // 231\n                                                                                // 232\n// Returns an array of all rules that apply to provided input                   // 233\nRateLimiter.prototype._findAllMatchingRules = function (input) {                // 234\n  var self = this;                                                              // 235\n                                                                                // 236\n  return _.filter(self.rules, function(rule) {                                  // 237\n    return rule.match(input);                                                   // 238\n  });                                                                           // 239\n};                                                                              // 240\n/**                                                                             // 241\n * Provides a mechanism to remove rules from the rate limiter. Returns boolean  // 242\n * about success.                                                               // 243\n * @param  {string} id Rule id returned from #addRule                           // 244\n * @return {boolean} Returns true if rule was found and deleted, else false.    // 245\n */                                                                             // 246\nRateLimiter.prototype.removeRule = function (id) {                              // 247\n  var self = this;                                                              // 248\n  if (self.rules[id]) {                                                         // 249\n    delete self.rules[id];                                                      // 250\n    return true;                                                                // 251\n  } else {                                                                      // 252\n    return false;                                                               // 253\n  }                                                                             // 254\n};                                                                              // 255\n                                                                                // 256\n//////////////////////////////////////////////////////////////////////////////////     // 265\n                                                                                       // 266\n}).call(this);                                                                         // 267\n                                                                                       // 268\n/////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['rate-limit'] = {\n  RateLimiter: RateLimiter\n};\n\n})();\n","servePath":"/packages/rate-limit.js","sourceMap":{"version":3,"sources":["/packages/rate-limit/packages/rate-limit.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6F","file":"/packages/rate-limit.js","sourcesContent":["(function(){\n\n//////////////////////////////////////////////////////////////////////////////////\n//                                                                              //\n// packages/rate-limit/rate-limit.js                                            //\n//                                                                              //\n//////////////////////////////////////////////////////////////////////////////////\n                                                                                //\n// Default time interval (in milliseconds) to reset rate limit counters         // 1\nvar DEFAULT_INTERVAL_TIME_IN_MILLISECONDS = 1000;                               // 2\n// Default number of events allowed per time interval                           // 3\nvar DEFAULT_REQUESTS_PER_INTERVAL = 10;                                         // 4\n                                                                                // 5\n// A rule is defined by an options object that contains two fields,             // 6\n// `numRequestsAllowed` which is the number of events allowed per interval, and\n// an `intervalTime` which is the amount of time in milliseconds before the     // 8\n// rate limit restarts its internal counters, and by a matchers object. A       // 9\n// matchers object is a POJO that contains a set of keys with values that       // 10\n// define the entire set of inputs that match for each key. The values can      // 11\n// either be null (optional), a primitive or a function that returns a boolean  // 12\n// of whether the provided input's value matches for this key.                  // 13\n//                                                                              // 14\n// Rules are uniquely assigned an `id` and they store a dictionary of counters,\n// which are records used to keep track of inputs that match the rule. If a     // 16\n// counter reaches the `numRequestsAllowed` within a given `intervalTime`, a    // 17\n// rate limit is reached and future inputs that map to that counter will        // 18\n// result in errors being returned to the client.                               // 19\nvar Rule = function (options, matchers) {                                       // 20\n  var self = this;                                                              // 21\n                                                                                // 22\n  self.id = Random.id();                                                        // 23\n                                                                                // 24\n  self.options = options;                                                       // 25\n                                                                                // 26\n  self._matchers = matchers;                                                    // 27\n                                                                                // 28\n  self._lastResetTime = new Date().getTime();                                   // 29\n                                                                                // 30\n  // Dictionary of input keys to counters                                       // 31\n  self.counters = {};                                                           // 32\n};                                                                              // 33\n                                                                                // 34\n_.extend(Rule.prototype, {                                                      // 35\n  // Determine if this rule applies to the given input by comparing all         // 36\n  // rule.matchers. If the match fails, search short circuits instead of        // 37\n  // iterating through all matchers.                                            // 38\n  match: function (input) {                                                     // 39\n    var self = this;                                                            // 40\n    var ruleMatches = true;                                                     // 41\n    return _.every(self._matchers, function (matcher, key) {                    // 42\n      if (matcher !== null) {                                                   // 43\n        if (!(_.has(input,key))) {                                              // 44\n          return false;                                                         // 45\n        } else {                                                                // 46\n          if (typeof matcher === 'function') {                                  // 47\n            if (!(matcher(input[key]))) {                                       // 48\n              return false;                                                     // 49\n            }                                                                   // 50\n          } else {                                                              // 51\n            if (matcher !== input[key]) {                                       // 52\n              return false;                                                     // 53\n            }                                                                   // 54\n          }                                                                     // 55\n        }                                                                       // 56\n      }                                                                         // 57\n      return true;                                                              // 58\n    });                                                                         // 59\n  },                                                                            // 60\n                                                                                // 61\n  // Generates unique key string for provided input by concatenating all the    // 62\n  // keys in the matcher with the corresponding values in the input.            // 63\n  // Only called if rule matches input.                                         // 64\n  _generateKeyString: function (input) {                                        // 65\n    var self = this;                                                            // 66\n    var returnString = \"\";                                                      // 67\n    _.each(self._matchers, function (matcher, key) {                            // 68\n      if (matcher !== null) {                                                   // 69\n        if (typeof matcher === 'function') {                                    // 70\n          if (matcher(input[key])) {                                            // 71\n            returnString += key + input[key];                                   // 72\n          }                                                                     // 73\n        } else {                                                                // 74\n          returnString += key + input[key];                                     // 75\n        }                                                                       // 76\n      }                                                                         // 77\n    });                                                                         // 78\n    return returnString;                                                        // 79\n  },                                                                            // 80\n                                                                                // 81\n  // Applies the provided input and returns the key string, time since counters\n  // were last reset and time to next reset.                                    // 83\n  apply: function (input) {                                                     // 84\n    var self = this;                                                            // 85\n    var keyString = self._generateKeyString(input);                             // 86\n    var timeSinceLastReset = new Date().getTime() - self._lastResetTime;        // 87\n    var timeToNextReset = self.options.intervalTime - timeSinceLastReset;       // 88\n    return {                                                                    // 89\n      key: keyString,                                                           // 90\n      timeSinceLastReset: timeSinceLastReset,                                   // 91\n      timeToNextReset: timeToNextReset                                          // 92\n    };                                                                          // 93\n  },                                                                            // 94\n  // Reset counter dictionary for this specific rule. Called once the           // 95\n  // timeSinceLastReset has exceeded the intervalTime. _lastResetTime is        // 96\n  // set to be the current time in milliseconds.                                // 97\n  resetCounter: function () {                                                   // 98\n    var self = this;                                                            // 99\n                                                                                // 100\n    // Delete the old counters dictionary to allow for garbage collection       // 101\n    self.counters = {};                                                         // 102\n    self._lastResetTime = new Date().getTime();                                 // 103\n  }                                                                             // 104\n});                                                                             // 105\n                                                                                // 106\n// Initialize rules to be an empty dictionary.                                  // 107\nRateLimiter = function () {                                                     // 108\n  var self = this;                                                              // 109\n                                                                                // 110\n  // Dictionary of all rules associated with this RateLimiter, keyed by their   // 111\n  // id. Each rule object stores the rule pattern, number of events allowed,    // 112\n  // last reset time and the rule reset interval in milliseconds.               // 113\n  self.rules = {};                                                              // 114\n};                                                                              // 115\n                                                                                // 116\n/**                                                                             // 117\n * Checks if this input has exceeded any rate limits.                           // 118\n * @param  {object} input dictionary containing key-value pairs of attributes   // 119\n * that match to rules                                                          // 120\n * @return {object} Returns object of following structure                       // 121\n * { 'allowed': boolean - is this input allowed                                 // 122\n *   'timeToReset': integer | Infinity - returns time until counters are reset  // 123\n *                   in milliseconds                                            // 124\n *   'numInvocationsLeft': integer | Infinity - returns number of calls left    // 125\n *   before limit is reached                                                    // 126\n * }                                                                            // 127\n * If multiple rules match, the least number of invocations left is returned.   // 128\n * If the rate limit has been reached, the longest timeToReset is returned.     // 129\n */                                                                             // 130\nRateLimiter.prototype.check = function (input) {                                // 131\n  var self = this;                                                              // 132\n  var reply = {                                                                 // 133\n    allowed: true,                                                              // 134\n    timeToReset: 0,                                                             // 135\n    numInvocationsLeft: Infinity                                                // 136\n  };                                                                            // 137\n                                                                                // 138\n  var matchedRules = self._findAllMatchingRules(input);                         // 139\n  _.each(matchedRules, function (rule) {                                        // 140\n    var ruleResult = rule.apply(input);                                         // 141\n    var numInvocations = rule.counters[ruleResult.key];                         // 142\n                                                                                // 143\n    if (ruleResult.timeToNextReset < 0) {                                       // 144\n      // Reset all the counters since the rule has reset                        // 145\n      rule.resetCounter();                                                      // 146\n      ruleResult.timeSinceLastReset = new Date().getTime() -                    // 147\n        rule._lastResetTime;                                                    // 148\n      ruleResult.timeToNextReset = rule.options.intervalTime;                   // 149\n      numInvocations = 0;                                                       // 150\n    }                                                                           // 151\n                                                                                // 152\n    if (numInvocations > rule.options.numRequestsAllowed) {                     // 153\n      // Only update timeToReset if the new time would be longer than the       // 154\n      // previously set time. This is to ensure that if this input triggers     // 155\n      // multiple rules, we return the longest period of time until they can    // 156\n      // successfully make another call                                         // 157\n      if (reply.timeToReset < ruleResult.timeToNextReset) {                     // 158\n        reply.timeToReset = ruleResult.timeToNextReset;                         // 159\n      };                                                                        // 160\n      reply.allowed = false;                                                    // 161\n      reply.numInvocationsLeft = 0;                                             // 162\n    } else {                                                                    // 163\n      // If this is an allowed attempt and we haven't failed on any of the      // 164\n      // other rules that match, update the reply field.                        // 165\n      if (rule.options.numRequestsAllowed - numInvocations <                    // 166\n        reply.numInvocationsLeft && reply.allowed) {                            // 167\n        reply.timeToReset = ruleResult.timeToNextReset;                         // 168\n        reply.numInvocationsLeft = rule.options.numRequestsAllowed -            // 169\n          numInvocations;                                                       // 170\n      }                                                                         // 171\n    }                                                                           // 172\n  });                                                                           // 173\n  return reply;                                                                 // 174\n};                                                                              // 175\n                                                                                // 176\n/**                                                                             // 177\n * Adds a rule to dictionary of rules that are checked against on every call.   // 178\n * Only inputs that pass all of the rules will be allowed. Returns unique rule  // 179\n * id that can be passed to `removeRule`.                                       // 180\n * @param {object} rule    Input dictionary defining certain attributes and     // 181\n * rules associated with them.                                                  // 182\n * Each attribute's value can either be a value, a function or null. All        // 183\n * functions must return a boolean of whether the input is matched by that      // 184\n * attribute's rule or not                                                      // 185\n * @param {integer} numRequestsAllowed Optional. Number of events allowed per   // 186\n * interval. Default = 10.                                                      // 187\n * @param {integer} intervalTime Optional. Number of milliseconds before        // 188\n * rule's counters are reset. Default = 1000.                                   // 189\n * @return {string} Returns unique rule id                                      // 190\n */                                                                             // 191\nRateLimiter.prototype.addRule = function (rule, numRequestsAllowed,             // 192\n  intervalTime) {                                                               // 193\n  var self = this;                                                              // 194\n                                                                                // 195\n  var options = {                                                               // 196\n    numRequestsAllowed: numRequestsAllowed || DEFAULT_REQUESTS_PER_INTERVAL,    // 197\n    intervalTime: intervalTime || DEFAULT_INTERVAL_TIME_IN_MILLISECONDS         // 198\n  };                                                                            // 199\n                                                                                // 200\n  var newRule = new Rule(options, rule);                                        // 201\n  this.rules[newRule.id] = newRule;                                             // 202\n  return newRule.id;                                                            // 203\n};                                                                              // 204\n                                                                                // 205\n/**                                                                             // 206\n * Increment counters in every rule that match to this input                    // 207\n * @param  {object} input Dictionary object containing attributes that may      // 208\n * match to rules                                                               // 209\n */                                                                             // 210\nRateLimiter.prototype.increment = function (input) {                            // 211\n  var self = this;                                                              // 212\n                                                                                // 213\n  // Only increment rule counters that match this input                         // 214\n  var matchedRules = self._findAllMatchingRules(input);                         // 215\n  _.each(matchedRules, function (rule) {                                        // 216\n    var ruleResult = rule.apply(input);                                         // 217\n                                                                                // 218\n    if (ruleResult.timeSinceLastReset > rule.options.intervalTime) {            // 219\n      // Reset all the counters since the rule has reset                        // 220\n      rule.resetCounter();                                                      // 221\n    }                                                                           // 222\n                                                                                // 223\n    // Check whether the key exists, incrementing it if so or otherwise         // 224\n    // adding the key and setting its value to 1                                // 225\n    if (_.has(rule.counters, ruleResult.key))                                   // 226\n      rule.counters[ruleResult.key]++;                                          // 227\n    else                                                                        // 228\n      rule.counters[ruleResult.key] = 1;                                        // 229\n  });                                                                           // 230\n};                                                                              // 231\n                                                                                // 232\n// Returns an array of all rules that apply to provided input                   // 233\nRateLimiter.prototype._findAllMatchingRules = function (input) {                // 234\n  var self = this;                                                              // 235\n                                                                                // 236\n  return _.filter(self.rules, function(rule) {                                  // 237\n    return rule.match(input);                                                   // 238\n  });                                                                           // 239\n};                                                                              // 240\n/**                                                                             // 241\n * Provides a mechanism to remove rules from the rate limiter. Returns boolean  // 242\n * about success.                                                               // 243\n * @param  {string} id Rule id returned from #addRule                           // 244\n * @return {boolean} Returns true if rule was found and deleted, else false.    // 245\n */                                                                             // 246\nRateLimiter.prototype.removeRule = function (id) {                              // 247\n  var self = this;                                                              // 248\n  if (self.rules[id]) {                                                         // 249\n    delete self.rules[id];                                                      // 250\n    return true;                                                                // 251\n  } else {                                                                      // 252\n    return false;                                                               // 253\n  }                                                                             // 254\n};                                                                              // 255\n                                                                                // 256\n//////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}}]