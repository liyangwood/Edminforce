{"version":3,"sources":["meteor://ðŸ’»app/packages/velocity_meteor-internals/packages/velocity_meteor-internals.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qG","file":"/packages/velocity_meteor-internals.js","sourcesContent":["(function () {\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                      //\n// packages/velocity:meteor-internals/main.js                                           //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n                                                                                        //\nVelocityMeteorInternals = {}                                                            // 1\n                                                                                        // 2\n//////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                      //\n// packages/velocity:meteor-internals/tools/parse-stack.js                              //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n                                                                                        //\nvar exports = {};                                                                       // 1\nVelocityMeteorInternals.parseStack = exports;                                           // 2\n                                                                                        // 3\n// Decorator. Mark the point at which a stack trace returned by                         // 4\n// parse() should stop: no frames earlier than this point will be                       // 5\n// included in the parsed stack. Confusingly, in the argot of the                       // 6\n// times, you'd say that frames \"higher up\" than this or \"above\" this                   // 7\n// will not be returned, but you'd also say that those frames are \"at                   // 8\n// the bottom of the stack\". Frames below the bottom are the outer                      // 9\n// context of the framework running the user's code.                                    // 10\nexports.markBottom = function (f) {                                                     // 11\n  return function __bottom_mark__ () {                                                  // 12\n    return f.apply(this, arguments);                                                    // 13\n  };                                                                                    // 14\n};                                                                                      // 15\n                                                                                        // 16\n//////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                      //\n// packages/velocity:meteor-internals/tools/buildmessage.js                             //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n                                                                                        //\n// Given a function f, return a \"marked\" version of f. The mark                         // 1\n// indicates that stack traces should stop just above f. So if you                      // 2\n// mark a user-supplied callback function before calling it, you'll be                  // 3\n// able to show the user just the \"user portion\" of the stack trace                     // 4\n// (the part inside their own code, and not all of the innards of the                   // 5\n// code that called it).                                                                // 6\nvar markBoundary = function (f) {                                                       // 7\n  return VelocityMeteorInternals.parseStack.markBottom(f);                              // 8\n};                                                                                      // 9\n                                                                                        // 10\n                                                                                        // 11\nVelocityMeteorInternals.buildmessage = {                                                // 12\n  markBoundary: markBoundary                                                            // 13\n};                                                                                      // 14\n                                                                                        // 15\n//////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                      //\n// packages/velocity:meteor-internals/tools/files.js                                    //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n                                                                                        //\n/**                                                                                     // 1\n * Copied from Meteor tools/files.js.                                                   // 2\n *                                                                                      // 3\n * Includes:                                                                            // 4\n * - Helper to find the app root path                                                   // 5\n * - Helper to run JavaScript                                                           // 6\n */                                                                                     // 7\n                                                                                        // 8\n///                                                                                     // 9\n/// utility functions for files and directories. includes both generic                  // 10\n/// helper functions (such as rm_recursive), and meteor-specific ones                   // 11\n/// (such as testing whether an directory is a meteor app)                              // 12\n///                                                                                     // 13\n                                                                                        // 14\nvar fs = Npm.require(\"fs\");                                                             // 15\nvar path = Npm.require('path');                                                         // 16\nvar Fiber = Npm.require('fibers');                                                      // 17\nvar Future = Npm.require('fibers/future');                                              // 18\nvar sourcemap = Npm.require('source-map');                                              // 19\nvar sourcemap_support = Npm.require('source-map-support');                              // 20\n                                                                                        // 21\nvar files = {};                                                                         // 22\nVelocityMeteorInternals.files = files;                                                  // 23\n                                                                                        // 24\nvar parsedSourceMaps = {};                                                              // 25\nvar nextStackFilenameCounter = 1;                                                       // 26\nvar retrieveSourceMap = function (pathForSourceMap) {                                   // 27\n  if (_.has(parsedSourceMaps, pathForSourceMap))                                        // 28\n    return {map: parsedSourceMaps[pathForSourceMap]};                                   // 29\n  return null;                                                                          // 30\n};                                                                                      // 31\n                                                                                        // 32\nsourcemap_support.install({                                                             // 33\n  // Use the source maps specified to runJavaScript instead of parsing source           // 34\n  // code for them.                                                                     // 35\n  retrieveSourceMap: retrieveSourceMap,                                                 // 36\n  // For now, don't fix the source line in uncaught exceptions, because we              // 37\n  // haven't fixed handleUncaughtExceptions in source-map-support to properly           // 38\n  // locate the source files.                                                           // 39\n  handleUncaughtExceptions: false                                                       // 40\n});                                                                                     // 41\n                                                                                        // 42\n// given a predicate function and a starting path, traverse upwards                     // 43\n// from the path until we find a path that satisfies the predicate.                     // 44\n//                                                                                      // 45\n// returns either the path to the lowest level directory that passed                    // 46\n// the test or null for none found. if starting path isn't given, use                   // 47\n// cwd.                                                                                 // 48\nvar findUpwards = function (predicate, startPath) {                                     // 49\n  var testDir = startPath || files.cwd();                                               // 50\n  while (testDir) {                                                                     // 51\n    if (predicate(testDir)) {                                                           // 52\n      break;                                                                            // 53\n    }                                                                                   // 54\n    var newDir = files.pathDirname(testDir);                                            // 55\n    if (newDir === testDir) {                                                           // 56\n      testDir = null;                                                                   // 57\n    } else {                                                                            // 58\n      testDir = newDir;                                                                 // 59\n    }                                                                                   // 60\n  }                                                                                     // 61\n  if (!testDir)                                                                         // 62\n    return null;                                                                        // 63\n                                                                                        // 64\n  return testDir;                                                                       // 65\n};                                                                                      // 66\n                                                                                        // 67\nfiles.cwd = function () {                                                               // 68\n  return files.convertToStandardPath(process.cwd());                                    // 69\n};                                                                                      // 70\n                                                                                        // 71\n// Determine if 'filepath' (a path, or omit for cwd) is within an app                   // 72\n// directory. If so, return the top-level app directory.                                // 73\nfiles.findAppDir = function (filepath) {                                                // 74\n  var isAppDir = function (filepath) {                                                  // 75\n    // XXX once we are done with the transition to engine, this should                  // 76\n    // change to: `return files.exists(path.join(filepath, '.meteor',                   // 77\n    // 'release'))`                                                                     // 78\n                                                                                        // 79\n    // .meteor/packages can be a directory, if .meteor is a warehouse                   // 80\n    // directory.  since installing meteor initializes a warehouse at                   // 81\n    // $HOME/.meteor, we want to make sure your home directory (and all                 // 82\n    // subdirectories therein) don't count as being within a meteor app.                // 83\n    try { // use try/catch to avoid the additional syscall to files.exists              // 84\n      return files.stat(                                                                // 85\n        files.pathJoin(filepath, '.meteor', 'packages')).isFile();                      // 86\n    } catch (e) {                                                                       // 87\n      return false;                                                                     // 88\n    }                                                                                   // 89\n  };                                                                                    // 90\n                                                                                        // 91\n  return findUpwards(isAppDir, filepath);                                               // 92\n};                                                                                      // 93\n                                                                                        // 94\nfiles.findPackageDir = function (filepath) {                                            // 95\n  var isPackageDir = function (filepath) {                                              // 96\n    try {                                                                               // 97\n      return files.stat(files.pathJoin(filepath, 'package.js')).isFile();               // 98\n    } catch (e) {                                                                       // 99\n      return false;                                                                     // 100\n    }                                                                                   // 101\n  };                                                                                    // 102\n                                                                                        // 103\n  return findUpwards(isPackageDir, filepath);                                           // 104\n};                                                                                      // 105\n                                                                                        // 106\n// Like statSync, but null if file not found                                            // 107\nfiles.statOrNull = function (path) {                                                    // 108\n  try {                                                                                 // 109\n    return files.stat(path);                                                            // 110\n  } catch (e) {                                                                         // 111\n    if (e.code == \"ENOENT\" || e.code == \"ENOTDIR\")                                      // 112\n      return null;                                                                      // 113\n    throw e;                                                                            // 114\n  }                                                                                     // 115\n};                                                                                      // 116\n                                                                                        // 117\n// Return the result of evaluating `code` using                                         // 118\n// `runInThisContext`. `code` will be wrapped in a closure. You can                     // 119\n// pass additional values to bind in the closure in `options.symbols`,                  // 120\n// the keys being the symbols to bind and the values being their                        // 121\n// values. `options.filename` is the filename to use in exceptions                      // 122\n// that come from inside this code. `options.sourceMap` is an optional                  // 123\n// source map that represents the file.                                                 // 124\n//                                                                                      // 125\n// The really special thing about this function is that if a parse                      // 126\n// error occurs, we will raise an exception of type                                     // 127\n// files.FancySyntaxError, from which you may read 'message', 'file',                   // 128\n// 'line', and 'column' attributes ... v8 is normally reluctant to                      // 129\n// reveal this information but will write it to stderr if you pass it                   // 130\n// an undocumented flag. Unforunately though node doesn't have dup2 so                  // 131\n// we can't intercept the write. So instead we use a completely                         // 132\n// different parser with a better error handling API. Ah well.  The                     // 133\n// underlying V8 issue is:                                                              // 134\n//   https://code.google.com/p/v8/issues/detail?id=1281                                 // 135\nfiles.runJavaScript = function (code, options) {                                        // 136\n  if (typeof code !== 'string')                                                         // 137\n    throw new Error(\"code must be a string\");                                           // 138\n                                                                                        // 139\n  options = options || {};                                                              // 140\n  var filename = options.filename || \"<anonymous>\";                                     // 141\n  var keys = [], values = [];                                                           // 142\n  // don't assume that _.keys and _.values are guaranteed to                            // 143\n  // enumerate in the same order                                                        // 144\n  _.each(options.symbols, function (value, name) {                                      // 145\n    keys.push(name);                                                                    // 146\n    values.push(value);                                                                 // 147\n  });                                                                                   // 148\n                                                                                        // 149\n  var stackFilename = filename;                                                         // 150\n  if (options.sourceMap) {                                                              // 151\n    // We want to generate an arbitrary filename that we use to associate the           // 152\n    // file with its source map.                                                        // 153\n    stackFilename = \"<runJavaScript-\" + nextStackFilenameCounter++ + \">\";               // 154\n  }                                                                                     // 155\n                                                                                        // 156\n  var chunks = [];                                                                      // 157\n  var header = \"(function(\" + keys.join(',') + \"){\";                                    // 158\n  chunks.push(header);                                                                  // 159\n  if (options.sourceMap) {                                                              // 160\n    var consumer = new sourcemap.SourceMapConsumer(options.sourceMap);                  // 161\n    chunks.push(sourcemap.SourceNode.fromStringWithSourceMap(                           // 162\n      code, consumer));                                                                 // 163\n  } else {                                                                              // 164\n    chunks.push(code);                                                                  // 165\n  }                                                                                     // 166\n  // \\n is necessary in case final line is a //-comment                                 // 167\n  chunks.push(\"\\n})\");                                                                  // 168\n                                                                                        // 169\n  var wrapped;                                                                          // 170\n  var parsedSourceMap = null;                                                           // 171\n  if (options.sourceMap) {                                                              // 172\n    var node = new sourcemap.SourceNode(null, null, null, chunks);                      // 173\n    var results = node.toStringWithSourceMap({                                          // 174\n      file: stackFilename                                                               // 175\n    });                                                                                 // 176\n    wrapped = results.code;                                                             // 177\n    parsedSourceMap = results.map.toJSON();                                             // 178\n    if (options.sourceMapRoot) {                                                        // 179\n      // Add the specified root to any root that may be in the file.                    // 180\n      parsedSourceMap.sourceRoot = files.pathJoin(                                      // 181\n        options.sourceMapRoot, parsedSourceMap.sourceRoot || '');                       // 182\n    }                                                                                   // 183\n    // source-map-support doesn't ever look at the sourcesContent field, so             // 184\n    // there's no point in keeping it in memory.                                        // 185\n    delete parsedSourceMap.sourcesContent;                                              // 186\n    parsedSourceMaps[stackFilename] = parsedSourceMap;                                  // 187\n  } else {                                                                              // 188\n    wrapped = chunks.join('');                                                          // 189\n  };                                                                                    // 190\n                                                                                        // 191\n  try {                                                                                 // 192\n    // See #runInThisContext                                                            // 193\n    //                                                                                  // 194\n    // XXX it'd be nice to runInNewContext so that the code can't mess                  // 195\n    // with our globals, but objects that come out of runInNewContext                   // 196\n    // have bizarro antimatter prototype chains and break 'instanceof                   // 197\n    // Array'. for now, steer clear                                                     // 198\n    //                                                                                  // 199\n    // Pass 'true' as third argument if we want the parse error on                      // 200\n    // stderr (which we don't).                                                         // 201\n    var script = Npm.require('vm').createScript(wrapped, stackFilename);                // 202\n  } catch (nodeParseError) {                                                            // 203\n    if (!(nodeParseError instanceof SyntaxError))                                       // 204\n      throw nodeParseError;                                                             // 205\n    // Got a parse error. Unfortunately, we can't actually get the                      // 206\n    // location of the parse error from the SyntaxError; Node has some                  // 207\n    // hacky support for displaying it over stderr if you pass an                       // 208\n    // undocumented third argument to stackFilename, but that's not                     // 209\n    // what we want. See                                                                // 210\n    //    https://github.com/joyent/node/issues/3452                                    // 211\n    // for more information. One thing to try (and in fact, what an                     // 212\n    // early version of this function did) is to actually fork a new                    // 213\n    // node to run the code and parse its output. We instead run an                     // 214\n    // entirely different JS parser, from the esprima project, but                      // 215\n    // which at least has a nice API for reporting errors.                              // 216\n    var esprima = Npm.require('esprima');                                               // 217\n    try {                                                                               // 218\n      esprima.parse(wrapped);                                                           // 219\n    } catch (esprimaParseError) {                                                       // 220\n      // Is this actually an Esprima syntax error?                                      // 221\n      if (!('index' in esprimaParseError &&                                             // 222\n        'lineNumber' in esprimaParseError &&                                            // 223\n        'column' in esprimaParseError &&                                                // 224\n        'description' in esprimaParseError)) {                                          // 225\n        throw esprimaParseError;                                                        // 226\n      }                                                                                 // 227\n      var err = new files.FancySyntaxError;                                             // 228\n                                                                                        // 229\n      err.message = esprimaParseError.description;                                      // 230\n                                                                                        // 231\n      if (parsedSourceMap) {                                                            // 232\n        // XXX this duplicates code in computeGlobalReferences                          // 233\n        var consumer2 = new sourcemap.SourceMapConsumer(parsedSourceMap);               // 234\n        var original = consumer2.originalPositionFor({                                  // 235\n          line: esprimaParseError.lineNumber,                                           // 236\n          column: esprimaParseError.column - 1                                          // 237\n        });                                                                             // 238\n        if (original.source) {                                                          // 239\n          err.file = original.source;                                                   // 240\n          err.line = original.line;                                                     // 241\n          err.column = original.column + 1;                                             // 242\n          throw err;                                                                    // 243\n        }                                                                               // 244\n      }                                                                                 // 245\n                                                                                        // 246\n      err.file = filename;  // *not* stackFilename                                      // 247\n      err.line = esprimaParseError.lineNumber;                                          // 248\n      err.column = esprimaParseError.column;                                            // 249\n      // adjust errors on line 1 to account for our header                              // 250\n      if (err.line === 1) {                                                             // 251\n        err.column -= header.length;                                                    // 252\n      }                                                                                 // 253\n      throw err;                                                                        // 254\n    }                                                                                   // 255\n                                                                                        // 256\n    // What? Node thought that this was a parse error and esprima didn't? Eh,           // 257\n    // just throw Node's error and don't care too much about the line numbers           // 258\n    // being right.                                                                     // 259\n    throw nodeParseError;                                                               // 260\n  }                                                                                     // 261\n                                                                                        // 262\n  var func = script.runInThisContext();                                                 // 263\n                                                                                        // 264\n  return (VelocityMeteorInternals.buildmessage.markBoundary(func)).apply(null, values); // 265\n};                                                                                      // 266\n                                                                                        // 267\n// - message: an error message from the parser                                          // 268\n// - file: filename                                                                     // 269\n// - line: 1-based                                                                      // 270\n// - column: 1-based                                                                    // 271\nfiles.FancySyntaxError = function () {};                                                // 272\n                                                                                        // 273\n// Summary of cross platform file system handling strategy                              // 274\n                                                                                        // 275\n// There are three main pain points for handling files on Windows: slashes in           // 276\n// paths, line endings in text files, and colons/invalid characters in paths.           // 277\n                                                                                        // 278\n// 1. Slashes in file paths                                                             // 279\n                                                                                        // 280\n//   We have decided to store all paths inside the tool as unix-style paths in          // 281\n//   the style of CYGWIN. This means that all paths have forward slashes on all         // 282\n//   platforms, and C:\\ is converted to /c/ on Windows.                                 // 283\n                                                                                        // 284\n//   All of the methods in files.js know how to convert from these unixy paths          // 285\n//   to whatever type of path the underlying system prefers.                            // 286\n                                                                                        // 287\n//   The reason we chose this strategy because it was easier to make sure to use        // 288\n//   files.js everywhere instead of node's fs than to make sure every part of           // 289\n//   the tool correctly uses system-specific path separators. In addition, there        // 290\n//   are some parts of the tool where it is very hard to tell which strings are         // 291\n//   used as URLs and which are used as file paths. In some cases, a string can         // 292\n//   be used as both, meaning it has to have forward slashes no matter what.            // 293\n                                                                                        // 294\n// 2. Line endings in text files                                                        // 295\n                                                                                        // 296\n//   We have decided to convert all files read by the tool to Unix-style line           // 297\n//   endings for the same reasons as slashes above. In many parts of the tool,          // 298\n//   we assume that '\\n' is the line separator, and it can be hard to find all          // 299\n//   of the places and decide whether it is appropriate to use os.EOL. We do not        // 300\n//   convert anything on write. We will wait and see if anyone complains.               // 301\n                                                                                        // 302\n// 3. Colons and other invalid characters in file paths                                 // 303\n                                                                                        // 304\n//   This is not handled automatically by files.js. You need to be careful to           // 305\n//   escape any colons in package names, etc, before using a string as a file           // 306\n//   path.                                                                              // 307\n                                                                                        // 308\n//   A helpful file to import for this purpose is colon-converter.js, which also        // 309\n//   knows how to convert various configuration file formats.                           // 310\n                                                                                        // 311\n/**                                                                                     // 312\n * Wrap a function from node's fs module to use the right slashes for this OS           // 313\n * and run in a fiber, then assign it to the \"files\" namespace. Each call               // 314\n * creates a files.func that runs asynchronously with Fibers (yielding and              // 315\n * until the call is done), unless run outside a Fiber or in noYieldsAllowed, in        // 316\n * which case it uses fs.funcSync.                                                      // 317\n *                                                                                      // 318\n * @param  {String} fsFuncName         The name of the node fs function to wrap         // 319\n * @param  {Number[]} pathArgIndices Indices of arguments that have paths, these        // 320\n * arguments will be converted to the correct OS slashes                                // 321\n * @param  {Object} options        Some options for lesser-used cases                   // 322\n * @param {Boolean} options.noErr If true, the callback of the wrapped function         // 323\n * doesn't have a first \"error\" argument, for example in fs.exists.                     // 324\n * @param {Function} options.modifyReturnValue Pass in a function to modify the         // 325\n * return value                                                                         // 326\n */                                                                                     // 327\nfunction wrapFsFunc(fsFuncName, pathArgIndices, options) {                              // 328\n  options = options || {};                                                              // 329\n                                                                                        // 330\n  var fsFunc = fs[fsFuncName];                                                          // 331\n  var fsFuncSync = fs[fsFuncName + \"Sync\"];                                             // 332\n                                                                                        // 333\n  function wrapper() {                                                                  // 334\n    var argc = arguments.length;                                                        // 335\n    var args = new Array(argc);                                                         // 336\n    for (var i = 0; i < argc; ++i) {                                                    // 337\n      args[i] = arguments[i];                                                           // 338\n    }                                                                                   // 339\n                                                                                        // 340\n    for (var j = pathArgIndices.length - 1; j >= 0; --j) {                              // 341\n      i = pathArgIndices[j];                                                            // 342\n      args[i] = files.convertToOSPath(args[i]);                                         // 343\n    }                                                                                   // 344\n                                                                                        // 345\n    if (Fiber.current &&                                                                // 346\n      Fiber.yield && ! Fiber.yield.disallowed) {                                        // 347\n      var fut = new Future;                                                             // 348\n                                                                                        // 349\n      args.push(function callback(err, value) {                                         // 350\n        if (options.noErr) {                                                            // 351\n          fut.return(err);                                                              // 352\n        } else if (err) {                                                               // 353\n          fut.throw(err);                                                               // 354\n        } else {                                                                        // 355\n          fut.return(value);                                                            // 356\n        }                                                                               // 357\n      });                                                                               // 358\n                                                                                        // 359\n      fsFunc.apply(fs, args);                                                           // 360\n                                                                                        // 361\n      var result = fut.wait();                                                          // 362\n      return options.modifyReturnValue                                                  // 363\n        ? options.modifyReturnValue(result)                                             // 364\n        : result;                                                                       // 365\n    }                                                                                   // 366\n                                                                                        // 367\n    // If we're not in a Fiber, run the sync version of the fs.* method.                // 368\n    var result = fsFuncSync.apply(fs, args);                                            // 369\n    return options.modifyReturnValue                                                    // 370\n      ? options.modifyReturnValue(result)                                               // 371\n      : result;                                                                         // 372\n  }                                                                                     // 373\n                                                                                        // 374\n  wrapper.displayName = fsFuncName;                                                     // 375\n  return files[fsFuncName] = wrapper;                                                   // 376\n}                                                                                       // 377\n                                                                                        // 378\nwrapFsFunc(\"writeFile\", [0]);                                                           // 379\nwrapFsFunc(\"appendFile\", [0]);                                                          // 380\nwrapFsFunc(\"readFile\", [0], {                                                           // 381\n  modifyReturnValue: function (fileData) {                                              // 382\n    if (_.isString(fileData)) {                                                         // 383\n      return files.convertToStandardLineEndings(fileData);                              // 384\n    }                                                                                   // 385\n                                                                                        // 386\n    return fileData;                                                                    // 387\n  }                                                                                     // 388\n});                                                                                     // 389\nwrapFsFunc(\"stat\", [0]);                                                                // 390\nwrapFsFunc(\"lstat\", [0]);                                                               // 391\nwrapFsFunc(\"exists\", [0], {noErr: true});                                               // 392\nwrapFsFunc(\"rename\", [0, 1]);                                                           // 393\n                                                                                        // 394\nif (process.platform === \"win32\") {                                                     // 395\n  var rename = files.rename;                                                            // 396\n                                                                                        // 397\n  files.rename = function (from, to) {                                                  // 398\n    // retries are necessarily only on Windows, because the rename call can fail        // 399\n    // with EBUSY, which means the file is \"busy\"                                       // 400\n    var maxTries = 10;                                                                  // 401\n    var success = false;                                                                // 402\n    while (! success && maxTries-- > 0) {                                               // 403\n      try {                                                                             // 404\n        rename(from, to);                                                               // 405\n        success = true;                                                                 // 406\n      } catch (err) {                                                                   // 407\n        if (err.code !== 'EPERM')                                                       // 408\n          throw err;                                                                    // 409\n      }                                                                                 // 410\n    }                                                                                   // 411\n    if (! success) {                                                                    // 412\n      files.cp_r(from, to);                                                             // 413\n      files.rm_recursive(from);                                                         // 414\n    }                                                                                   // 415\n  };                                                                                    // 416\n}                                                                                       // 417\n                                                                                        // 418\n// Warning: doesn't convert slashes in the second 'cache' arg                           // 419\nwrapFsFunc(\"realpath\", [0], {                                                           // 420\n  modifyReturnValue: files.convertToStandardPath                                        // 421\n});                                                                                     // 422\n                                                                                        // 423\nwrapFsFunc(\"readdir\", [0], {                                                            // 424\n  modifyReturnValue: function (entries) {                                               // 425\n    return _.map(entries, files.convertToStandardPath);                                 // 426\n  }                                                                                     // 427\n});                                                                                     // 428\n                                                                                        // 429\nwrapFsFunc(\"rmdir\", [0]);                                                               // 430\nwrapFsFunc(\"mkdir\", [0]);                                                               // 431\nwrapFsFunc(\"unlink\", [0]);                                                              // 432\nwrapFsFunc(\"chmod\", [0]);                                                               // 433\nwrapFsFunc(\"open\", [0]);                                                                // 434\n                                                                                        // 435\n// XXX this doesn't give you the second argument to the callback                        // 436\nwrapFsFunc(\"read\", []);                                                                 // 437\nwrapFsFunc(\"write\", []);                                                                // 438\nwrapFsFunc(\"close\", []);                                                                // 439\nwrapFsFunc(\"symlink\", [0, 1]);                                                          // 440\nwrapFsFunc(\"readlink\", [0]);                                                            // 441\n                                                                                        // 442\n// These don't need to be Fiberized                                                     // 443\nfiles.createReadStream = function () {                                                  // 444\n  var args = _.toArray(arguments);                                                      // 445\n  args[0] = files.convertToOSPath(args[0]);                                             // 446\n  return fs.createReadStream.apply(fs, args);                                           // 447\n};                                                                                      // 448\n                                                                                        // 449\nfiles.createWriteStream = function () {                                                 // 450\n  var args = _.toArray(arguments);                                                      // 451\n  args[0] = files.convertToOSPath(args[0]);                                             // 452\n  return fs.createWriteStream.apply(fs, args);                                          // 453\n};                                                                                      // 454\n                                                                                        // 455\nfiles.watchFile = function () {                                                         // 456\n  var args = _.toArray(arguments);                                                      // 457\n  args[0] = files.convertToOSPath(args[0]);                                             // 458\n  return fs.watchFile.apply(fs, args);                                                  // 459\n};                                                                                      // 460\n                                                                                        // 461\nfiles.unwatchFile = function () {                                                       // 462\n  var args = _.toArray(arguments);                                                      // 463\n  args[0] = files.convertToOSPath(args[0]);                                             // 464\n  return fs.unwatchFile.apply(fs, args);                                                // 465\n};                                                                                      // 466\n                                                                                        // 467\n//////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                      //\n// packages/velocity:meteor-internals/tools/server/mini-files.js                        //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n                                                                                        //\nvar _ = Npm.require(\"underscore\");                                                      // 1\nvar os = Npm.require(\"os\");                                                             // 2\nvar path = Npm.require(\"path\");                                                         // 3\n                                                                                        // 4\n// All of these functions are attached to files.js for the tool;                        // 5\n// they live here because we need them in boot.js as well to avoid duplicating          // 6\n// a lot of the code.                                                                   // 7\n//                                                                                      // 8\n// Note that this file does NOT contain any of the \"perform I/O maybe                   // 9\n// synchronously\" functions from files.js; this is intentional, because we want         // 10\n// to make it very hard to accidentally use fs.*Sync functions in the app server        // 11\n// after bootup (since they block all concurrency!)                                     // 12\nvar files = {};                                                                         // 13\n                                                                                        // 14\nvar toPosixPath = function (p, partialPath) {                                           // 15\n  // Sometimes, you can have a path like \\Users\\IEUser on windows, and this             // 16\n  // actually means you want C:\\Users\\IEUser                                            // 17\n  if (p[0] === \"\\\\\" && (! partialPath)) {                                               // 18\n    p = process.env.SystemDrive + p;                                                    // 19\n  }                                                                                     // 20\n                                                                                        // 21\n  p = p.replace(/\\\\/g, '/');                                                            // 22\n  if (p[1] === ':' && ! partialPath) {                                                  // 23\n    // transform \"C:/bla/bla\" to \"/c/bla/bla\"                                           // 24\n    p = '/' + p[0] + p.slice(2);                                                        // 25\n  }                                                                                     // 26\n                                                                                        // 27\n  return p;                                                                             // 28\n};                                                                                      // 29\n                                                                                        // 30\nvar toDosPath = function (p, partialPath) {                                             // 31\n  if (p[0] === '/' && ! partialPath) {                                                  // 32\n    if (! /^\\/[A-Za-z](\\/|$)/.test(p))                                                  // 33\n      throw new Error(\"Surprising path: \" + p);                                         // 34\n    // transform a previously windows path back                                         // 35\n    // \"/C/something\" to \"c:/something\"                                                 // 36\n    p = p[1] + \":\" + p.slice(2);                                                        // 37\n  }                                                                                     // 38\n                                                                                        // 39\n  p = p.replace(/\\//g, '\\\\');                                                           // 40\n  return p;                                                                             // 41\n};                                                                                      // 42\n                                                                                        // 43\n                                                                                        // 44\nvar convertToOSPath = function (standardPath, partialPath) {                            // 45\n  if (process.platform === \"win32\") {                                                   // 46\n    return toDosPath(standardPath, partialPath);                                        // 47\n  }                                                                                     // 48\n                                                                                        // 49\n  return standardPath;                                                                  // 50\n};                                                                                      // 51\n                                                                                        // 52\nvar convertToStandardPath = function (osPath, partialPath) {                            // 53\n  if (process.platform === \"win32\") {                                                   // 54\n    return toPosixPath(osPath, partialPath);                                            // 55\n  }                                                                                     // 56\n                                                                                        // 57\n  return osPath;                                                                        // 58\n}                                                                                       // 59\n                                                                                        // 60\nvar convertToOSLineEndings = function (fileContents) {                                  // 61\n  return fileContents.replace(/\\n/g, os.EOL);                                           // 62\n};                                                                                      // 63\n                                                                                        // 64\nvar convertToStandardLineEndings = function (fileContents) {                            // 65\n  // Convert all kinds of end-of-line chars to linuxy \"\\n\".                             // 66\n  return fileContents.replace(new RegExp(\"\\r\\n\", \"g\"), \"\\n\")                            // 67\n                     .replace(new RegExp(\"\\r\", \"g\"), \"\\n\");                             // 68\n};                                                                                      // 69\n                                                                                        // 70\n                                                                                        // 71\n// wrappings for path functions that always run as they were on unix (using             // 72\n// forward slashes)                                                                     // 73\nvar wrapPathFunction = function (name, partialPaths) {                                  // 74\n  var f = path[name];                                                                   // 75\n  return function (/* args */) {                                                        // 76\n    if (process.platform === 'win32') {                                                 // 77\n      var args = _.toArray(arguments);                                                  // 78\n      args = _.map(args, function (p, i) {                                              // 79\n        // if partialPaths is turned on (for path.join mostly)                          // 80\n        // forget about conversion of absolute paths for Windows                        // 81\n        return toDosPath(p, partialPaths);                                              // 82\n      });                                                                               // 83\n      return toPosixPath(f.apply(path, args), partialPaths);                            // 84\n    } else {                                                                            // 85\n      return f.apply(path, arguments);                                                  // 86\n    }                                                                                   // 87\n  };                                                                                    // 88\n};                                                                                      // 89\n                                                                                        // 90\nfiles.pathJoin = wrapPathFunction(\"join\", true);                                        // 91\nfiles.pathNormalize = wrapPathFunction(\"normalize\");                                    // 92\nfiles.pathRelative = wrapPathFunction(\"relative\");                                      // 93\nfiles.pathResolve = wrapPathFunction(\"resolve\");                                        // 94\nfiles.pathDirname = wrapPathFunction(\"dirname\");                                        // 95\nfiles.pathBasename = wrapPathFunction(\"basename\");                                      // 96\nfiles.pathExtname = wrapPathFunction(\"extname\");                                        // 97\nfiles.pathSep = '/';                                                                    // 98\nfiles.pathDelimiter = ':';                                                              // 99\nfiles.pathOsDelimiter = path.delimiter;                                                 // 100\n                                                                                        // 101\nfiles.convertToStandardPath = convertToStandardPath;                                    // 102\nfiles.convertToOSPath = convertToOSPath;                                                // 103\nfiles.convertToWindowsPath = toDosPath;                                                 // 104\nfiles.convertToPosixPath = toPosixPath;                                                 // 105\n                                                                                        // 106\nfiles.convertToStandardLineEndings = convertToStandardLineEndings;                      // 107\nfiles.convertToOSLineEndings = convertToOSLineEndings;                                  // 108\n                                                                                        // 109\n_.extend(VelocityMeteorInternals.files, files);                                         // 110\n                                                                                        // 111\n//////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}