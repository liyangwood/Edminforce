{"version":3,"sources":["meteor://ðŸ’»app/packages/ihealth_utils/lib/declarations.js","meteor://ðŸ’»app/packages/ihealth_utils/lib/callbacks.js","meteor://ðŸ’»app/packages/ihealth_utils/lib/utils.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yH;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yH;;;;;;;;;;;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H","file":"/packages/ihealth_utils.js","sourcesContent":["\n/**\n * Declaration\n */\nIH = {\n  Callbacks: {},\n  Coll: {},\n  RC: {},\n  Schema: {},\n}\n","/*\n  Ref: Telescope.callbacks [ https://github.com/TelescopeJS/Telescope ]\n  TODO: organize and customize; will move to a separate package\n */\n\n/*\nCallback hooks provide an easy way to add extra steps to common operations.\n@namespace IH.Callbacks\n */\n\n/*\nAdd a callback function to a hook\n@param {String} hook - The name of the hook\n@param {Function} callback - The callback function\n */\n\nIH.Callbacks.Add = function(hook, callback) {\n  if (typeof IH.Callbacks[hook] === \"undefined\") {\n    IH.Callbacks[hook] = [];\n  }\n  return IH.Callbacks[hook].push(callback);\n};\n\n\n/*\nRemove a callback from a hook\n@param {string} hook - The name of the hook\n@param {string} functionName - The name of the function to remove\n */\n\nIH.Callbacks.Remove = function(hookName, callbackName) {\n  return IH.Callbacks[hookName] = _.reject(IH.Callbacks[hookName], function(callback) {\n    return callback.name === callbackName;\n  });\n};\n\n\n/*\nSuccessively run all of a hook's callbacks on an item\n@param {String} hook - The name of the hook\n@param {Object} item - The post, comment, modifier, etc. on which to run the callbacks\n@param {Object} [constant] - An optional constant that will be passed along to each callback\n@returns {Object} Returns the item after it's been through all the callbacks for this hook\n */\n\nIH.Callbacks.Run = function(hook, item, constant) {\n  var callbacks = IH.Callbacks[hook];\n  if (typeof callbacks !== \"undefined\" && !!callbacks.length) {\n    return callbacks.reduce((function(result, callback) {\n      return callback(result, constant);\n    }), item);\n  } else {\n    return item;\n  }\n};\n\n\n/*\nSuccessively run all of a hook's callbacks on an item, in async mode (only works on server)\n@param {String} hook - The name of the hook\n@param {Object} item - The post, comment, modifier, etc. on which to run the callbacks\n@param {Object} [constant] - An optional constant that will be passed along to each callback\n */\n\nIH.Callbacks.RunAsync = function(hook, item, constant) {\n  var callbacks = IH.Callbacks[hook];\n  if (Meteor.isServer && typeof callbacks !== \"undefined\" && !!callbacks.length) {\n    return Meteor.defer(function() {\n      return callbacks.forEach(function(callback) {\n        return callback(item, constant);\n      });\n    });\n  } else {\n    return item;\n  }\n}\n","\n/**\n * Helper Functions for both Client & Server\n */\nh = {\n  ltrim: function(str){\n    return str.replace(/^\\s+/,\"\")\n  },\n  rtrim: function(str){\n    return str.replace(/\\s+$/,\"\")\n  },\n  time_format: function(time, return_full){\n    var read = moment(time).format(\"h:mm a\")\n    if (!return_full) return read\n\n    return {\n      time: read,\n\n      // TODO:\n      // Replace days_past with \"past\" and add W/D/Y in a differnet key\n      days_past: moment().diff( moment(time), \"days\")\n    }\n  },\n  getPlatform: function(test) {\n    var platform = (Meteor.isCordova && device.platform ? device.platform : \"web\").toLowerCase()\n    return test ? platform==test : platform\n  },\n  nk: function(object, key) {\n\t\tif( !_.isString(key)) return false\n\n\t\tvar key = key.replace(/\\[(\\w+)\\]/g, '.$1') // convert indexes to properties\n\t\tkey = key.replace(/^\\./, '') // strip a leading dot\n\n\t\tif (key.indexOf('.')<=0)\n\t\t\treturn object[ key] || null\n\n\t\tvar split = key.split('.')\n\t\twhile (split.length) {\n\t\t\tvar n = split.shift()\n\t\t\tif (_.isObject(object) && n in object)\n\t\t\t\tobject = object[n]\n\t\t\telse\n\t\t\t\treturn null\n\t\t}\n    return object\n\t},\n  random_string: function(len){\n\t\tvar do_rand = function(){\n\t\t\treturn (0|Math.random()*9e6).toString(36)\n\t\t}\n\n\t\tif(isNaN(len))\n\t\t\treturn do_rand()\n\n\t\tvar rand = ''\n\t\tfor( var i = Math.floor(len/4); i>=0; i-- ){\n\t\t\trand += do_rand()\n\t\t}\n\t\treturn rand.substr(0,len)\n\t},\n  to_read: function(str) {\n    if (!_.isString(str)) return\n    return str.toLowerCase().trim().replace(/ /g, \"-\")\n  },\n  capitalize: function(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1)\n  },\n}\n\nif (Meteor.isClient){\n  // ##\n  // Client Only Helper Functions\n\n  /**\n   * Get all the device informations from Session\n   */\n  h.getDevices = function(type){\n    var devices = Session.get(\"devices\") || { bluetooth: false }\n    return type ? devices[type] : devices\n  }\n  /**\n   * Save device informations to Session\n   */\n  h.saveDevices = function(session, connected){\n    var cur = Session.get(\"devices\") || { bluetooth: false }\n    var compare = _.clone(cur)\n\n    if (!_.isObject(session)) session = {}\n    if (connected) session.bluetooth = true\n    _.extend(cur,session)\n\n    if (!_.isEqual(compare,cur))\n      Session.set(\"devices\", cur) // Cur is Extended\n  }\n\t/*\n\t * Wait until a condition returns true before doing a function.\n\t * @check = A function that determines whether the check interval should continue\n\t * @completeFunc = Function to run after check is true\n\t * @delay = Delay between each check interval\n\t * @timeout = Give up after this timeout duration if check still fails\n\t */\n\th.wait_for = function(check, completeFunc, delay, timeout) {\n\t\t// if the check returns true, execute onComplete immediately\n\t\tif (check()) {\n\t\t  completeFunc()\n\t\t  return\n\t\t}\n\t\tvar onComplete = function(){\n\t\t\tMeteor.setTimeout( function(){\n\t\t\t\tcompleteFunc()\n\t\t\t},100)\n\t\t}\n\t\tif (!delay) delay=100\n\t\tvar count = 1 // This incremends every loop, creating a longer interval periods in case something went wrong\n\t\tvar intervalPointer = null\n\n\t\t// if after timeout milliseconds function doesn't return true, abort\n\t\tvar timeoutPointer = timeout ?\n\t\t\tMeteor.setTimeout(function() {\n\t\t\t  Meteor.clearTimeout(intervalPointer)\n\t\t\t}, timeout) : null\n\n\t\tvar interval_func = function() {\n\t\t\tif (!check())\n\t\t\t\tintervalPointer = Meteor.setTimeout(interval_func, delay)\n\t\t\telse {\n\t\t\t\t// if the check returned true, means we're done here. clear the interval and the timeout and execute onComplete\n\t\t\t\tif (timeoutPointer) Meteor.clearTimeout(timeoutPointer)\n\t\t\t\tonComplete()\n\t\t\t}\n\t\t}\n\t\tintervalPointer = Meteor.setTimeout(interval_func, delay)\n\t}\n  h.returnComponent = function(tmpl, props){\n    if (!React) return null\n    var props = _.isObject(props) ? props : null\n    if (_.isObject(tmpl)) {\n      if (props)\n        return React.cloneElement(tmpl, props)\n      return tmpl\n    } else if (_.isString(tmpl) && window[tmpl])\n      return React.createElement(window[tmpl], props)\n    else if (RC)\n      return React.createElement(RC.NotFound)\n  }\n  h.serializeForm = function(form){\n\t\tvar formData = _.map($(form).serializeArray(), function(data) {\n      const name = _.isString(data.name) ? data.name.trim() : data.name\n      const value = _.isString(data.value) ? data.value.trim() : data.value\n\t\t\treturn [name, value]\n\t\t})\n\t\treturn _.object(formData)\n\t}\n  h.getDomPos = function(el, args){\n    var defs = {\n      reverse: false,\n      xOffset: 0,\n      yOffset: 0,\n    }\n    if (_.isObject(args)) _.defaults(args, defs); else args = defs;\n\n    var pos = el.getBoundingClientRect()\n\n    if (args.reverse) {\n      pos.x = window.innerWidth - pos.left - pos.width - args.xOffset\n      pos.y = window.innerHeight - pos.top - args.yOffset\n    } else {\n      pos.x = pos.left + pos.width + args.xOffset\n      pos.y = pos.top + args.yOffset\n    }\n\n    return pos\n  }\n  h.strToArray = function(str){\n    if (!_.isString(str))\n      return str\n    return _.filter( str.replace(/,/g, \" \").split(\" \"), function(t){\n      return t.length\n    })\n  }\n  h.checkColorClass = function(css){\n    return _.isString(css) && _.contains([\"brand-light\",\"brand\",\"brand1\",\"brand2\",\"brand3\",\"white\",\"dark\",\"gray\",\"blue\",\"green\",\"light\",\"stable\"], css.trim())\n  }\n}\n\n\nif (Meteor.isServer){\n  // ##\n  // Server Only Helper Functions\n}\n"]}