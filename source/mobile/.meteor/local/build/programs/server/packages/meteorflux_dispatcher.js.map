{"version":3,"sources":["meteor://ðŸ’»app/packages/meteorflux_dispatcher/lib/dispatcher.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qF","file":"/packages/meteorflux_dispatcher.js","sourcesContent":["\nvar _lastID = 1;\nvar _prefix = 'ID_';\n\nvar invariant = function(condition, errorMessage, format, a, b, c, d, e, f) {\n  if (!condition) {\n    var error;\n    if ((format === undefined)||(errorMessage === undefined)) {\n      error = new Meteor.Error(\n        'minified-exception',\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Meteor.Error(\n        errorMessage,\n        'Invariant Violation: ' +\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n    }\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\n/**\n* MeteorFlux.Dispatcher is used to broadcast payloads to registered callbacks.\n*/\n\nMeteorFlux.Dispatcher = function(){\n  this._callbacks = {};\n  this._isPending = {};\n  this._isHandled = {};\n  this._isDispatching = false;\n  this._pendingPayload = null;\n};\n\n\n/**\n* Registers a callback to be invoked with every dispatched payload. Returns\n* a token that can be used with `waitFor()`.\n*\n* @param {function} callback\n* @return {string}\n*/\nMeteorFlux.Dispatcher.prototype.register = function(/* arguments */) {\n  var callback = this._curateCallback.apply(this, arguments);\n  var id = _prefix + _lastID++;\n  this._callbacks[id] = callback;\n  return id;\n};\n\n/**\n* Removes a callback based on its token.\n*\n* @param {string} id\n*/\nMeteorFlux.Dispatcher.prototype.unregister = function(id) {\n  invariant(\n    this._callbacks[id],\n    'dispatcher-unregister-not-map',\n    'Dispatcher.unregister(...): `%s` does not map to a registered callback.',\n    id\n  );\n  delete this._callbacks[id];\n};\n\n/**\n* Waits for the callbacks specified to be invoked before continuing execution\n* of the current callback. This method should only be used by a callback in\n* response to a dispatched payload.\n*\n* @param {array<string>} ids\n*/\nMeteorFlux.Dispatcher.prototype.waitFor = function(ids) {\n  invariant(\n    this._isDispatching,\n    'dispatcher-waitfor-invoked-outside-dispatch',\n    'Dispatcher.waitFor(...): Must be invoked while dispatching.'\n  );\n  for (var ii = 0; ii < ids.length; ii++) {\n    var id = ids[ii];\n    if (this._isPending[id]) {\n      invariant(\n        this._isHandled[id],\n        'dispatcher-waitfor-circular-dependency',\n        'Dispatcher.waitFor(...): Circular dependency detected while ' +\n        'waiting for `%s`.',\n        id\n      );\n      continue;\n    }\n    invariant(\n      this._callbacks[id],\n      'dispatcher-waitfor-invalid-token',\n      'Dispatcher.waitFor(...): `%s` does not map to a registered callback.',\n      id\n    );\n    this._invokeCallback(id);\n  }\n};\n\n/**\n* Dispatches a payload to all registered callbacks.\n*\n* @param {object} payload\n*/\nMeteorFlux.Dispatcher.prototype.dispatch = function(/* arguments */) {\n  invariant(\n    !this._isDispatching,\n    'dispatcher-cant-dispatch-while-dispatching',\n    'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.'\n  );\n  var payload = this._curatePayload.apply(this, arguments);\n  this._startDispatching(payload);\n  try {\n    for (var id in this._callbacks) {\n      if (this._isPending[id]) {\n        continue;\n      }\n      this._invokeCallback(id);\n    }\n  } finally {\n    this._stopDispatching();\n  }\n};\n\n/**\n* Is this MeteorFlux.Dispatcher currently dispatching.\n*\n* @return {boolean}\n*/\nMeteorFlux.Dispatcher.prototype.isDispatching = function() {\n  return this._isDispatching;\n};\n\n/**\n* Call the callback stored with the given id. Also do some internal\n* bookkeeping.\n*\n* @param {string} id\n* @internal\n*/\nMeteorFlux.Dispatcher.prototype._invokeCallback = function(id) {\n  this._isPending[id] = true;\n  this._callbacks[id](this._pendingPayload);\n  this._isHandled[id] = true;\n};\n\n/**\n* Set up bookkeeping needed when dispatching.\n*\n* @param {object} payload\n* @internal\n*/\nMeteorFlux.Dispatcher.prototype._startDispatching = function(payload) {\n  for (var id in this._callbacks) {\n    this._isPending[id] = false;\n    this._isHandled[id] = false;\n  }\n  this._pendingPayload = payload;\n  this._isDispatching = true;\n};\n\n/**\n* Clear bookkeeping used for dispatching.\n*\n* @internal\n*/\nMeteorFlux.Dispatcher.prototype._stopDispatching = function() {\n  this._pendingPayload = null;\n  this._isDispatching = false;\n};\n\n\n/**\n* Curate the payload. If the user uses the first argument as string, use it\n* as action type and include it in the payload.\n*\n* @internal\n*/\nMeteorFlux.Dispatcher.prototype._curatePayload = function(/* arguments */) {\n  if (typeof arguments[0] === 'string') {\n    var action = arguments[1] || {};\n    action.type = arguments[0];\n    return action;\n  } else {\n    return arguments[0];\n  }\n};\n\n/**\n* Curate the payload. If the user uses the first argument as string, use it\n* as action type and include it in the payload.\n*\n* @internal\n*/\nMeteorFlux.Dispatcher.prototype._curateCallback = function(/* arguments */) {\n  if (typeof arguments[0] === 'string') {\n    var type = arguments[0];\n    var func = arguments[1];\n    return function(action) {\n      if (action.type === type)\n        func(action);\n    };\n  } else {\n    return arguments[0];\n  }\n};\n\n/**\n* Reset everything. Created for testing purposes\n*\n*/\nMeteorFlux.Dispatcher.prototype.reset = function() {\n  this._callbacks = {};\n  this._isPending = {};\n  this._isHandled = {};\n  this._isDispatching = false;\n  this._pendingPayload = null;\n};\n\n/**\n* The main Dispatcher instance that clients will deal with\n*\n* @exports Dispatcher\n*/\n\nDispatcher = new MeteorFlux.Dispatcher();\n"]}