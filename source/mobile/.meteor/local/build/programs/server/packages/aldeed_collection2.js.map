{"version":3,"sources":["meteor://ðŸ’»app/packages/aldeed_collection2/packages/aldeed_collection2.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2E","file":"/packages/aldeed_collection2.js","sourcesContent":["(function () {\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/aldeed:collection2/collection2.js                                                                        //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n/* global Meteor, _, SimpleSchema, Mongo:true, Match, Package, EJSON */                                              // 1\n                                                                                                                     // 2\n// Extend the schema options allowed by SimpleSchema                                                                 // 3\nSimpleSchema.extendOptions({                                                                                         // 4\n  index: Match.Optional(Match.OneOf(Number, String, Boolean)),                                                       // 5\n  unique: Match.Optional(Boolean),                                                                                   // 6\n  denyInsert: Match.Optional(Boolean),                                                                               // 7\n  denyUpdate: Match.Optional(Boolean)                                                                                // 8\n});                                                                                                                  // 9\n                                                                                                                     // 10\n// Define some extra validation error messages                                                                       // 11\nSimpleSchema.messages({                                                                                              // 12\n  notUnique: \"[label] must be unique\",                                                                               // 13\n  insertNotAllowed: \"[label] cannot be set during an insert\",                                                        // 14\n  updateNotAllowed: \"[label] cannot be set during an update\"                                                         // 15\n});                                                                                                                  // 16\n                                                                                                                     // 17\n/*                                                                                                                   // 18\n * Public API                                                                                                        // 19\n */                                                                                                                  // 20\n                                                                                                                     // 21\n// backwards compatibility                                                                                           // 22\nif (typeof Mongo === \"undefined\") {                                                                                  // 23\n  Mongo = {};                                                                                                        // 24\n  Mongo.Collection = Meteor.Collection;                                                                              // 25\n}                                                                                                                    // 26\n                                                                                                                     // 27\n/**                                                                                                                  // 28\n * Mongo.Collection.prototype.attachSchema                                                                           // 29\n * @param {SimpleSchema|Object} ss - SimpleSchema instance or a schema definition object from which to create a new SimpleSchema instance\n * @param {Object} [options]                                                                                         // 31\n * @param {Boolean} [options.transform=false] Set to `true` if your document must be passed through the collection's transform to properly validate.\n * @param {Boolean} [options.replace=false] Set to `true` to replace any existing schema instead of combining        // 33\n * @return {undefined}                                                                                               // 34\n *                                                                                                                   // 35\n * Use this method to attach a schema to a collection created by another package,                                    // 36\n * such as Meteor.users. It is most likely unsafe to call this method more than                                      // 37\n * once for a single collection, or to call this for a collection that had a                                         // 38\n * schema object passed to its constructor.                                                                          // 39\n */                                                                                                                  // 40\nMongo.Collection.prototype.attachSchema = function c2AttachSchema(ss, options) {                                     // 41\n  var self = this;                                                                                                   // 42\n  options = options || {};                                                                                           // 43\n                                                                                                                     // 44\n  if (!(ss instanceof SimpleSchema)) {                                                                               // 45\n    ss = new SimpleSchema(ss);                                                                                       // 46\n  }                                                                                                                  // 47\n                                                                                                                     // 48\n  self._c2 = self._c2 || {};                                                                                         // 49\n                                                                                                                     // 50\n  // If we've already attached one schema, we combine both into a new schema unless options.replace is `true`        // 51\n  if (self._c2._simpleSchema && options.replace !== true) {                                                          // 52\n    ss = new SimpleSchema([self._c2._simpleSchema, ss]);                                                             // 53\n  }                                                                                                                  // 54\n                                                                                                                     // 55\n  // Track the schema in the collection                                                                              // 56\n  self._c2._simpleSchema = ss;                                                                                       // 57\n                                                                                                                     // 58\n  function ensureIndex(c, index, indexName, unique, sparse) {                                                        // 59\n    Meteor.startup(function () {                                                                                     // 60\n      c._collection._ensureIndex(index, {                                                                            // 61\n        background: true,                                                                                            // 62\n        name: indexName,                                                                                             // 63\n        unique: unique,                                                                                              // 64\n        sparse: sparse                                                                                               // 65\n      });                                                                                                            // 66\n    });                                                                                                              // 67\n  }                                                                                                                  // 68\n                                                                                                                     // 69\n  function dropIndex(c, indexName) {                                                                                 // 70\n    Meteor.startup(function () {                                                                                     // 71\n      try {                                                                                                          // 72\n        c._collection._dropIndex(indexName);                                                                         // 73\n      } catch (err) {                                                                                                // 74\n        // no index with that name, which is what we want                                                            // 75\n      }                                                                                                              // 76\n    });                                                                                                              // 77\n  }                                                                                                                  // 78\n                                                                                                                     // 79\n  // Loop over fields definitions and ensure collection indexes (server side only)                                   // 80\n  if (Meteor.isServer) {                                                                                             // 81\n    _.each(ss.schema(), function(definition, fieldName) {                                                            // 82\n      if ('index' in definition || definition.unique === true) {                                                     // 83\n        var index = {}, indexValue;                                                                                  // 84\n        // If they specified `unique: true` but not `index`,                                                         // 85\n        // we assume `index: 1` to set up the unique index in mongo                                                  // 86\n        if ('index' in definition) {                                                                                 // 87\n          indexValue = definition.index;                                                                             // 88\n          if (indexValue === true) {                                                                                 // 89\n            indexValue = 1;                                                                                          // 90\n          }                                                                                                          // 91\n        } else {                                                                                                     // 92\n          indexValue = 1;                                                                                            // 93\n        }                                                                                                            // 94\n        var indexName = 'c2_' + fieldName;                                                                           // 95\n        // In the index object, we want object array keys without the \".$\" piece                                     // 96\n        var idxFieldName = fieldName.replace(/\\.\\$\\./g, \".\");                                                        // 97\n        index[idxFieldName] = indexValue;                                                                            // 98\n        var unique = !!definition.unique && (indexValue === 1 || indexValue === -1);                                 // 99\n        var sparse = !!definition.optional && unique;                                                                // 100\n                                                                                                                     // 101\n        if (indexValue === false) {                                                                                  // 102\n          dropIndex(self, indexName);                                                                                // 103\n        } else {                                                                                                     // 104\n          ensureIndex(self, index, indexName, unique, sparse);                                                       // 105\n        }                                                                                                            // 106\n      }                                                                                                              // 107\n    });                                                                                                              // 108\n  }                                                                                                                  // 109\n                                                                                                                     // 110\n  // Set up additional checks                                                                                        // 111\n  ss.validator(function() {                                                                                          // 112\n    var def = this.definition;                                                                                       // 113\n    var val = this.value;                                                                                            // 114\n    var op = this.operator;                                                                                          // 115\n                                                                                                                     // 116\n    if (def.denyInsert && val !== void 0 && !op) {                                                                   // 117\n      // This is an insert of a defined value into a field where denyInsert=true                                     // 118\n      return \"insertNotAllowed\";                                                                                     // 119\n    }                                                                                                                // 120\n                                                                                                                     // 121\n    if (def.denyUpdate && op) {                                                                                      // 122\n      // This is an insert of a defined value into a field where denyUpdate=true                                     // 123\n      if (op !== \"$set\" || (op === \"$set\" && val !== void 0)) {                                                      // 124\n        return \"updateNotAllowed\";                                                                                   // 125\n      }                                                                                                              // 126\n    }                                                                                                                // 127\n                                                                                                                     // 128\n    return true;                                                                                                     // 129\n  });                                                                                                                // 130\n                                                                                                                     // 131\n  defineDeny(self, options);                                                                                         // 132\n  keepInsecure(self);                                                                                                // 133\n};                                                                                                                   // 134\n                                                                                                                     // 135\nMongo.Collection.prototype.simpleSchema = function c2SS() {                                                          // 136\n  var self = this;                                                                                                   // 137\n  return self._c2 ? self._c2._simpleSchema : null;                                                                   // 138\n};                                                                                                                   // 139\n                                                                                                                     // 140\n// Wrap DB write operation methods                                                                                   // 141\n_.each(['insert', 'update', 'upsert'], function(methodName) {                                                        // 142\n    var _super = Mongo.Collection.prototype[methodName];                                                             // 143\n    Mongo.Collection.prototype[methodName] = function() {                                                            // 144\n        var self = this,                                                                                             // 145\n            args = _.toArray(arguments);                                                                             // 146\n        if (self._c2) {                                                                                              // 147\n                                                                                                                     // 148\n            var userId = null;                                                                                       // 149\n            try { // https://github.com/aldeed/meteor-collection2/issues/175                                         // 150\n                userId = Meteor.userId();                                                                            // 151\n            } catch (err) {}                                                                                         // 152\n                                                                                                                     // 153\n            args = doValidate.call(self, methodName, args, false, userId, Meteor.isServer);                          // 154\n            if (!args) {                                                                                             // 155\n                // doValidate already called the callback or threw the error                                         // 156\n                if (methodName === \"insert\") {                                                                       // 157\n                    // insert should always return an ID to match core behavior                                      // 158\n                    return self._makeNewID();                                                                        // 159\n                } else {                                                                                             // 160\n                    return;                                                                                          // 161\n                }                                                                                                    // 162\n            }                                                                                                        // 163\n        }                                                                                                            // 164\n        return _super.apply(self, args);                                                                             // 165\n    };                                                                                                               // 166\n});                                                                                                                  // 167\n                                                                                                                     // 168\n/*                                                                                                                   // 169\n * Private                                                                                                           // 170\n */                                                                                                                  // 171\n                                                                                                                     // 172\nfunction doValidate(type, args, skipAutoValue, userId, isFromTrustedCode) {                                          // 173\n  var self = this, schema = self._c2._simpleSchema,                                                                  // 174\n      doc, callback, error, options, isUpsert, selector, last, hasCallback,                                          // 175\n      isLocalCollection = (self._connection === null);                                                               // 176\n                                                                                                                     // 177\n  if (!args.length) {                                                                                                // 178\n    throw new Error(type + \" requires an argument\");                                                                 // 179\n  }                                                                                                                  // 180\n                                                                                                                     // 181\n  // Gather arguments and cache the selector                                                                         // 182\n  if (type === \"insert\") {                                                                                           // 183\n    doc = args[0];                                                                                                   // 184\n    options = args[1];                                                                                               // 185\n    callback = args[2];                                                                                              // 186\n                                                                                                                     // 187\n    // The real insert doesn't take options                                                                          // 188\n    if (typeof options === \"function\") {                                                                             // 189\n      args = [doc, options];                                                                                         // 190\n    } else if (typeof callback === \"function\") {                                                                     // 191\n      args = [doc, callback];                                                                                        // 192\n    } else {                                                                                                         // 193\n      args = [doc];                                                                                                  // 194\n    }                                                                                                                // 195\n                                                                                                                     // 196\n  } else if (type === \"update\" || type === \"upsert\") {                                                               // 197\n    selector = args[0];                                                                                              // 198\n    doc = args[1];                                                                                                   // 199\n    options = args[2];                                                                                               // 200\n    callback = args[3];                                                                                              // 201\n  } else {                                                                                                           // 202\n    throw new Error(\"invalid type argument\");                                                                        // 203\n  }                                                                                                                  // 204\n                                                                                                                     // 205\n  // Support missing options arg                                                                                     // 206\n  if (!callback && typeof options === \"function\") {                                                                  // 207\n    callback = options;                                                                                              // 208\n    options = {};                                                                                                    // 209\n  }                                                                                                                  // 210\n  options = options || {};                                                                                           // 211\n                                                                                                                     // 212\n  last = args.length - 1;                                                                                            // 213\n                                                                                                                     // 214\n  hasCallback = (typeof args[last] === 'function');                                                                  // 215\n                                                                                                                     // 216\n  // If update was called with upsert:true or upsert was called, flag as an upsert                                   // 217\n  isUpsert = (type === \"upsert\" || (type === \"update\" && options.upsert === true));                                  // 218\n                                                                                                                     // 219\n  // Add a default callback function if we're on the client and no callback was given                                // 220\n  if (Meteor.isClient && !callback) {                                                                                // 221\n    // Client can't block, so it can't report errors by exception,                                                   // 222\n    // only by callback. If they forget the callback, give them a                                                    // 223\n    // default one that logs the error, so they aren't totally                                                       // 224\n    // baffled if their writes don't work because their database is                                                  // 225\n    // down.                                                                                                         // 226\n    callback = function(err) {                                                                                       // 227\n      if (err) {                                                                                                     // 228\n        Meteor._debug(type + \" failed: \" + (err.reason || err.stack));                                               // 229\n      }                                                                                                              // 230\n    };                                                                                                               // 231\n  }                                                                                                                  // 232\n                                                                                                                     // 233\n  // If client validation is fine or is skipped but then something                                                   // 234\n  // is found to be invalid on the server, we get that error back                                                    // 235\n  // as a special Meteor.Error that we need to parse.                                                                // 236\n  if (Meteor.isClient && hasCallback) {                                                                              // 237\n    callback = args[last] = wrapCallbackForParsingServerErrors(self, options.validationContext, callback);           // 238\n  }                                                                                                                  // 239\n                                                                                                                     // 240\n  // If _id has already been added, remove it temporarily if it's                                                    // 241\n  // not explicitly defined in the schema.                                                                           // 242\n  var id;                                                                                                            // 243\n  if (doc._id && !schema.allowsKey(\"_id\")) {                                                                         // 244\n    id = doc._id;                                                                                                    // 245\n    delete doc._id;                                                                                                  // 246\n  }                                                                                                                  // 247\n                                                                                                                     // 248\n  function doClean(docToClean, getAutoValues, filter, autoConvert, removeEmptyStrings, trimStrings) {                // 249\n    // Clean the doc/modifier in place                                                                               // 250\n    schema.clean(docToClean, {                                                                                       // 251\n      filter: filter,                                                                                                // 252\n      autoConvert: autoConvert,                                                                                      // 253\n      getAutoValues: getAutoValues,                                                                                  // 254\n      isModifier: (type !== \"insert\"),                                                                               // 255\n      removeEmptyStrings: removeEmptyStrings,                                                                        // 256\n      trimStrings: trimStrings,                                                                                      // 257\n      extendAutoValueContext: _.extend({                                                                             // 258\n        isInsert: (type === \"insert\"),                                                                               // 259\n        isUpdate: (type === \"update\" && options.upsert !== true),                                                    // 260\n        isUpsert: isUpsert,                                                                                          // 261\n        userId: userId,                                                                                              // 262\n        isFromTrustedCode: isFromTrustedCode,                                                                        // 263\n        docId: ((type === \"update\" || type === \"upsert\") && selector) ? selector._id || selector : void 0,           // 264\n        isLocalCollection: isLocalCollection                                                                         // 265\n      }, options.extendAutoValueContext || {})                                                                       // 266\n    });                                                                                                              // 267\n  }                                                                                                                  // 268\n                                                                                                                     // 269\n  // On the server and for local collections, we allow passing `getAutoValues: false` to disable autoValue functions // 270\n  if ((Meteor.isServer || isLocalCollection) && options.getAutoValues === false) {                                   // 271\n    skipAutoValue = true;                                                                                            // 272\n  }                                                                                                                  // 273\n                                                                                                                     // 274\n  // Preliminary cleaning on both client and server. On the server and for local                                     // 275\n  // collections, automatic values will also be set at this point.                                                   // 276\n  doClean(doc, ((Meteor.isServer || isLocalCollection) && !skipAutoValue), options.filter !== false, options.autoConvert !== false, options.removeEmptyStrings !== false, options.trimStrings !== false);\n                                                                                                                     // 278\n  // We clone before validating because in some cases we need to adjust the                                          // 279\n  // object a bit before validating it. If we adjusted `doc` itself, our                                             // 280\n  // changes would persist into the database.                                                                        // 281\n  var docToValidate = {};                                                                                            // 282\n  for (var prop in doc) {                                                                                            // 283\n    // We omit prototype properties when cloning because they will not be valid                                      // 284\n    // and mongo omits them when saving to the database anyway.                                                      // 285\n    if (doc.hasOwnProperty(prop)) {                                                                                  // 286\n      docToValidate[prop] = doc[prop];                                                                               // 287\n    }                                                                                                                // 288\n  }                                                                                                                  // 289\n                                                                                                                     // 290\n  // On the server, upserts are possible; SimpleSchema handles upserts pretty                                        // 291\n  // well by default, but it will not know about the fields in the selector,                                         // 292\n  // which are also stored in the database if an insert is performed. So we                                          // 293\n  // will allow these fields to be considered for validation by adding them                                          // 294\n  // to the $set in the modifier. This is no doubt prone to errors, but there                                        // 295\n  // probably isn't any better way right now.                                                                        // 296\n  if (Meteor.isServer && isUpsert && _.isObject(selector)) {                                                         // 297\n    var set = docToValidate.$set || {};                                                                              // 298\n    docToValidate.$set = _.clone(selector);                                                                          // 299\n    _.extend(docToValidate.$set, set);                                                                               // 300\n  }                                                                                                                  // 301\n                                                                                                                     // 302\n  // Set automatic values for validation on the client.                                                              // 303\n  // On the server, we already updated doc with auto values, but on the client,                                      // 304\n  // we will add them to docToValidate for validation purposes only.                                                 // 305\n  // This is because we want all actual values generated on the server.                                              // 306\n  if (Meteor.isClient && !isLocalCollection) {                                                                       // 307\n    doClean(docToValidate, true, false, false, false, false);                                                        // 308\n  }                                                                                                                  // 309\n                                                                                                                     // 310\n  // Validate doc                                                                                                    // 311\n  var ctx = schema.namedContext(options.validationContext);                                                          // 312\n  var isValid;                                                                                                       // 313\n  if (options.validate === false) {                                                                                  // 314\n    isValid = true;                                                                                                  // 315\n  } else {                                                                                                           // 316\n    isValid = ctx.validate(docToValidate, {                                                                          // 317\n      modifier: (type === \"update\" || type === \"upsert\"),                                                            // 318\n      upsert: isUpsert,                                                                                              // 319\n      extendedCustomContext: _.extend({                                                                              // 320\n        isInsert: (type === \"insert\"),                                                                               // 321\n        isUpdate: (type === \"update\" && options.upsert !== true),                                                    // 322\n        isUpsert: isUpsert,                                                                                          // 323\n        userId: userId,                                                                                              // 324\n        isFromTrustedCode: isFromTrustedCode,                                                                        // 325\n        docId: ((type === \"update\" || type === \"upsert\") && selector) ? selector._id || selector : void 0,           // 326\n        isLocalCollection: isLocalCollection                                                                         // 327\n      }, options.extendedCustomContext || {})                                                                        // 328\n    });                                                                                                              // 329\n  }                                                                                                                  // 330\n                                                                                                                     // 331\n  if (isValid) {                                                                                                     // 332\n    // Add the ID back                                                                                               // 333\n    if (id) {                                                                                                        // 334\n      doc._id = id;                                                                                                  // 335\n    }                                                                                                                // 336\n                                                                                                                     // 337\n    // Update the args to reflect the cleaned doc                                                                    // 338\n    if (type === \"insert\") {                                                                                         // 339\n      args[0] = doc;                                                                                                 // 340\n    } else {                                                                                                         // 341\n      args[1] = doc;                                                                                                 // 342\n    }                                                                                                                // 343\n                                                                                                                     // 344\n    // If callback, set invalidKey when we get a mongo unique error                                                  // 345\n    if (Meteor.isServer && hasCallback) {                                                                            // 346\n      args[last] = wrapCallbackForParsingMongoValidationErrors(self, doc, options.validationContext, args[last]);    // 347\n    }                                                                                                                // 348\n                                                                                                                     // 349\n    return args;                                                                                                     // 350\n  } else {                                                                                                           // 351\n    error = getErrorObject(ctx);                                                                                     // 352\n    if (callback) {                                                                                                  // 353\n      // insert/update/upsert pass `false` when there's an error, so we do that                                      // 354\n      callback(error, false);                                                                                        // 355\n    } else {                                                                                                         // 356\n      throw error;                                                                                                   // 357\n    }                                                                                                                // 358\n  }                                                                                                                  // 359\n}                                                                                                                    // 360\n                                                                                                                     // 361\nfunction getErrorObject(context) {                                                                                   // 362\n  var message, invalidKeys = context.invalidKeys();                                                                  // 363\n  if (invalidKeys.length) {                                                                                          // 364\n    message = context.keyErrorMessage(invalidKeys[0].name);                                                          // 365\n  } else {                                                                                                           // 366\n    message = \"Failed validation\";                                                                                   // 367\n  }                                                                                                                  // 368\n  var error = new Error(message);                                                                                    // 369\n  error.invalidKeys = invalidKeys;                                                                                   // 370\n  error.validationContext = context;                                                                                 // 371\n  // If on the server, we add a sanitized error, too, in case we're                                                  // 372\n  // called from a method.                                                                                           // 373\n  if (Meteor.isServer) {                                                                                             // 374\n    error.sanitizedError = new Meteor.Error(400, message);                                                           // 375\n  }                                                                                                                  // 376\n  return error;                                                                                                      // 377\n}                                                                                                                    // 378\n                                                                                                                     // 379\nfunction addUniqueError(context, errorMessage) {                                                                     // 380\n  var name = errorMessage.split('c2_')[1].split(' ')[0];                                                             // 381\n  var val = errorMessage.split('dup key:')[1].split('\"')[1];                                                         // 382\n  context.addInvalidKeys([{                                                                                          // 383\n    name: name,                                                                                                      // 384\n    type: 'notUnique',                                                                                               // 385\n    value: val                                                                                                       // 386\n  }]);                                                                                                               // 387\n}                                                                                                                    // 388\n                                                                                                                     // 389\nfunction wrapCallbackForParsingMongoValidationErrors(col, doc, vCtx, cb) {                                           // 390\n  return function wrappedCallbackForParsingMongoValidationErrors(error) {                                            // 391\n    if (error && ((error.name === \"MongoError\" && error.code === 11001) || error.message.indexOf('MongoError: E11000' !== -1)) && error.message.indexOf('c2_') !== -1) {\n      var context = col.simpleSchema().namedContext(vCtx);                                                           // 393\n      addUniqueError(context, error.message);                                                                        // 394\n      arguments[0] = getErrorObject(context);                                                                        // 395\n    }                                                                                                                // 396\n    return cb.apply(this, arguments);                                                                                // 397\n  };                                                                                                                 // 398\n}                                                                                                                    // 399\n                                                                                                                     // 400\nfunction wrapCallbackForParsingServerErrors(col, vCtx, cb) {                                                         // 401\n  return function wrappedCallbackForParsingServerErrors(error) {                                                     // 402\n    // Handle our own validation errors                                                                              // 403\n    var context = col.simpleSchema().namedContext(vCtx);                                                             // 404\n    if (error instanceof Meteor.Error && error.error === 400 && error.reason === \"INVALID\" && typeof error.details === \"string\") {\n      var invalidKeysFromServer = EJSON.parse(error.details);                                                        // 406\n      context.addInvalidKeys(invalidKeysFromServer);                                                                 // 407\n      arguments[0] = getErrorObject(context);                                                                        // 408\n    }                                                                                                                // 409\n    // Handle Mongo unique index errors, which are forwarded to the client as 409 errors                             // 410\n    else if (error instanceof Meteor.Error && error.error === 409 && error.reason && error.reason.indexOf('E11000') !== -1 && error.reason.indexOf('c2_') !== -1) {\n      addUniqueError(context, error.reason);                                                                         // 412\n      arguments[0] = getErrorObject(context);                                                                        // 413\n    }                                                                                                                // 414\n    return cb.apply(this, arguments);                                                                                // 415\n  };                                                                                                                 // 416\n}                                                                                                                    // 417\n                                                                                                                     // 418\nvar alreadyInsecured = {};                                                                                           // 419\nfunction keepInsecure(c) {                                                                                           // 420\n  // If insecure package is in use, we need to add allow rules that return                                           // 421\n  // true. Otherwise, it would seemingly turn off insecure mode.                                                     // 422\n  if (Package && Package.insecure && !alreadyInsecured[c._name]) {                                                   // 423\n    c.allow({                                                                                                        // 424\n      insert: function() {                                                                                           // 425\n        return true;                                                                                                 // 426\n      },                                                                                                             // 427\n      update: function() {                                                                                           // 428\n        return true;                                                                                                 // 429\n      },                                                                                                             // 430\n      remove: function () {                                                                                          // 431\n        return true;                                                                                                 // 432\n      },                                                                                                             // 433\n      fetch: [],                                                                                                     // 434\n      transform: null                                                                                                // 435\n    });                                                                                                              // 436\n    alreadyInsecured[c._name] = true;                                                                                // 437\n  }                                                                                                                  // 438\n  // If insecure package is NOT in use, then adding the two deny functions                                           // 439\n  // does not have any effect on the main app's security paradigm. The                                               // 440\n  // user will still be required to add at least one allow function of her                                           // 441\n  // own for each operation for this collection. And the user may still add                                          // 442\n  // additional deny functions, but does not have to.                                                                // 443\n}                                                                                                                    // 444\n                                                                                                                     // 445\nvar alreadyDefined = {};                                                                                             // 446\nfunction defineDeny(c, options) {                                                                                    // 447\n  if (!alreadyDefined[c._name]) {                                                                                    // 448\n                                                                                                                     // 449\n    var isLocalCollection = (c._connection === null);                                                                // 450\n                                                                                                                     // 451\n    // First define deny functions to extend doc with the results of clean                                           // 452\n    // and autovalues. This must be done with \"transform: null\" or we would be                                       // 453\n    // extending a clone of doc and therefore have no effect.                                                        // 454\n    c.deny({                                                                                                         // 455\n      insert: function(userId, doc) {                                                                                // 456\n        var ss = c.simpleSchema();                                                                                   // 457\n        // If _id has already been added, remove it temporarily if it's                                              // 458\n        // not explicitly defined in the schema.                                                                     // 459\n        var id;                                                                                                      // 460\n        if (Meteor.isServer && doc._id && !ss.allowsKey(\"_id\")) {                                                    // 461\n          id = doc._id;                                                                                              // 462\n          delete doc._id;                                                                                            // 463\n        }                                                                                                            // 464\n                                                                                                                     // 465\n        // Referenced doc is cleaned in place                                                                        // 466\n        ss.clean(doc, {                                                                                              // 467\n          isModifier: false,                                                                                         // 468\n          // We don't do these here because they are done on the client if desired                                   // 469\n          filter: false,                                                                                             // 470\n          autoConvert: false,                                                                                        // 471\n          removeEmptyStrings: false,                                                                                 // 472\n          trimStrings: false,                                                                                        // 473\n          extendAutoValueContext: {                                                                                  // 474\n            isInsert: true,                                                                                          // 475\n            isUpdate: false,                                                                                         // 476\n            isUpsert: false,                                                                                         // 477\n            userId: userId,                                                                                          // 478\n            isFromTrustedCode: false,                                                                                // 479\n            docId: id,                                                                                               // 480\n            isLocalCollection: isLocalCollection                                                                     // 481\n          }                                                                                                          // 482\n        });                                                                                                          // 483\n                                                                                                                     // 484\n        // Add the ID back                                                                                           // 485\n        if (id) {                                                                                                    // 486\n          doc._id = id;                                                                                              // 487\n        }                                                                                                            // 488\n                                                                                                                     // 489\n        return false;                                                                                                // 490\n      },                                                                                                             // 491\n      update: function(userId, doc, fields, modifier) {                                                              // 492\n        var ss = c.simpleSchema();                                                                                   // 493\n        // Referenced modifier is cleaned in place                                                                   // 494\n        ss.clean(modifier, {                                                                                         // 495\n          isModifier: true,                                                                                          // 496\n          // We don't do these here because they are done on the client if desired                                   // 497\n          filter: false,                                                                                             // 498\n          autoConvert: false,                                                                                        // 499\n          removeEmptyStrings: false,                                                                                 // 500\n          trimStrings: false,                                                                                        // 501\n          extendAutoValueContext: {                                                                                  // 502\n            isInsert: false,                                                                                         // 503\n            isUpdate: true,                                                                                          // 504\n            isUpsert: false,                                                                                         // 505\n            userId: userId,                                                                                          // 506\n            isFromTrustedCode: false,                                                                                // 507\n            docId: doc && doc._id,                                                                                   // 508\n            isLocalCollection: isLocalCollection                                                                     // 509\n          }                                                                                                          // 510\n        });                                                                                                          // 511\n                                                                                                                     // 512\n        return false;                                                                                                // 513\n      },                                                                                                             // 514\n      fetch: ['_id'],                                                                                                // 515\n      transform: null                                                                                                // 516\n    });                                                                                                              // 517\n                                                                                                                     // 518\n    // Second define deny functions to validate again on the server                                                  // 519\n    // for client-initiated inserts and updates. These should be                                                     // 520\n    // called after the clean/autovalue functions since we're adding                                                 // 521\n    // them after. These must *not* have \"transform: null\" if options.transform is true because                      // 522\n    // we need to pass the doc through any transforms to be sure                                                     // 523\n    // that custom types are properly recognized for type validation.                                                // 524\n    c.deny(_.extend({                                                                                                // 525\n      insert: function(userId, doc) {                                                                                // 526\n        // We pass the false options because we will have done them on client if desired                             // 527\n        doValidate.call(c, \"insert\", [doc, {trimStrings: false, removeEmptyStrings: false, filter: false, autoConvert: false}, function(error) {\n            if (error) {                                                                                             // 529\n              throw new Meteor.Error(400, 'INVALID', EJSON.stringify(error.invalidKeys));                            // 530\n            }                                                                                                        // 531\n          }], true, userId, false);                                                                                  // 532\n                                                                                                                     // 533\n        return false;                                                                                                // 534\n      },                                                                                                             // 535\n      update: function(userId, doc, fields, modifier) {                                                              // 536\n        // NOTE: This will never be an upsert because client-side upserts                                            // 537\n        // are not allowed once you define allow/deny functions.                                                     // 538\n        // We pass the false options because we will have done them on client if desired                             // 539\n        doValidate.call(c, \"update\", [{_id: doc && doc._id}, modifier, {trimStrings: false, removeEmptyStrings: false, filter: false, autoConvert: false}, function(error) {\n            if (error) {                                                                                             // 541\n              throw new Meteor.Error(400, 'INVALID', EJSON.stringify(error.invalidKeys));                            // 542\n            }                                                                                                        // 543\n          }], true, userId, false);                                                                                  // 544\n                                                                                                                     // 545\n        return false;                                                                                                // 546\n      },                                                                                                             // 547\n      fetch: ['_id']                                                                                                 // 548\n    }, options.transform === true ? {} : {transform: null}));                                                        // 549\n                                                                                                                     // 550\n    // note that we've already done this collection so that we don't do it again                                     // 551\n    // if attachSchema is called again                                                                               // 552\n    alreadyDefined[c._name] = true;                                                                                  // 553\n  }                                                                                                                  // 554\n}                                                                                                                    // 555\n                                                                                                                     // 556\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}